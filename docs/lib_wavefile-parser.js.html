<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/wavefile-parser.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-wavefile.html">wavefile</a><ul class='methods'><li data-type='method'><a href="module-wavefile.html#deleteCuePoint">deleteCuePoint</a></li><li data-type='method'><a href="module-wavefile.html#deleteTag">deleteTag</a></li><li data-type='method'><a href="module-wavefile.html#fromALaw">fromALaw</a></li><li data-type='method'><a href="module-wavefile.html#fromBase64">fromBase64</a></li><li data-type='method'><a href="module-wavefile.html#fromBuffer">fromBuffer</a></li><li data-type='method'><a href="module-wavefile.html#fromDataURI">fromDataURI</a></li><li data-type='method'><a href="module-wavefile.html#fromIMAADPCM">fromIMAADPCM</a></li><li data-type='method'><a href="module-wavefile.html#fromMuLaw">fromMuLaw</a></li><li data-type='method'><a href="module-wavefile.html#fromScratch">fromScratch</a></li><li data-type='method'><a href="module-wavefile.html#getSample">getSample</a></li><li data-type='method'><a href="module-wavefile.html#getTag">getTag</a></li><li data-type='method'><a href="module-wavefile.html#listCuePoints">listCuePoints</a></li><li data-type='method'><a href="module-wavefile.html#listTags">listTags</a></li><li data-type='method'><a href="module-wavefile.html#setCuePoint">setCuePoint</a></li><li data-type='method'><a href="module-wavefile.html#setSample">setSample</a></li><li data-type='method'><a href="module-wavefile.html#setTag">setTag</a></li><li data-type='method'><a href="module-wavefile.html#toALaw">toALaw</a></li><li data-type='method'><a href="module-wavefile.html#toBase64">toBase64</a></li><li data-type='method'><a href="module-wavefile.html#toBitDepth">toBitDepth</a></li><li data-type='method'><a href="module-wavefile.html#toBuffer">toBuffer</a></li><li data-type='method'><a href="module-wavefile.html#toDataURI">toDataURI</a></li><li data-type='method'><a href="module-wavefile.html#toIMAADPCM">toIMAADPCM</a></li><li data-type='method'><a href="module-wavefile.html#toMuLaw">toMuLaw</a></li><li data-type='method'><a href="module-wavefile.html#toRIFF">toRIFF</a></li><li data-type='method'><a href="module-wavefile.html#toRIFX">toRIFX</a></li><li data-type='method'><a href="module-wavefile.html#updateDataType">updateDataType</a></li><li data-type='method'><a href="module-wavefile.html#updateLabel">updateLabel</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-wavefile.html">wavefile</a><ul class='methods'><li data-type='method'><a href="module-wavefile.html#deleteCuePoint">deleteCuePoint</a></li><li data-type='method'><a href="module-wavefile.html#deleteTag">deleteTag</a></li><li data-type='method'><a href="module-wavefile.html#fromALaw">fromALaw</a></li><li data-type='method'><a href="module-wavefile.html#fromBase64">fromBase64</a></li><li data-type='method'><a href="module-wavefile.html#fromBuffer">fromBuffer</a></li><li data-type='method'><a href="module-wavefile.html#fromDataURI">fromDataURI</a></li><li data-type='method'><a href="module-wavefile.html#fromIMAADPCM">fromIMAADPCM</a></li><li data-type='method'><a href="module-wavefile.html#fromMuLaw">fromMuLaw</a></li><li data-type='method'><a href="module-wavefile.html#fromScratch">fromScratch</a></li><li data-type='method'><a href="module-wavefile.html#getSample">getSample</a></li><li data-type='method'><a href="module-wavefile.html#getTag">getTag</a></li><li data-type='method'><a href="module-wavefile.html#listCuePoints">listCuePoints</a></li><li data-type='method'><a href="module-wavefile.html#listTags">listTags</a></li><li data-type='method'><a href="module-wavefile.html#setCuePoint">setCuePoint</a></li><li data-type='method'><a href="module-wavefile.html#setSample">setSample</a></li><li data-type='method'><a href="module-wavefile.html#setTag">setTag</a></li><li data-type='method'><a href="module-wavefile.html#toALaw">toALaw</a></li><li data-type='method'><a href="module-wavefile.html#toBase64">toBase64</a></li><li data-type='method'><a href="module-wavefile.html#toBitDepth">toBitDepth</a></li><li data-type='method'><a href="module-wavefile.html#toBuffer">toBuffer</a></li><li data-type='method'><a href="module-wavefile.html#toDataURI">toDataURI</a></li><li data-type='method'><a href="module-wavefile.html#toIMAADPCM">toIMAADPCM</a></li><li data-type='method'><a href="module-wavefile.html#toMuLaw">toMuLaw</a></li><li data-type='method'><a href="module-wavefile.html#toRIFF">toRIFF</a></li><li data-type='method'><a href="module-wavefile.html#toRIFX">toRIFX</a></li><li data-type='method'><a href="module-wavefile.html#updateDataType">updateDataType</a></li><li data-type='method'><a href="module-wavefile.html#updateLabel">updateLabel</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/wavefile-parser.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) 2017-2019 Rafael da Silva Rocha.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * @fileoverview The WaveFileParser class.
 * @see https://github.com/rochars/wavefile
 */

/** @module wavefile */

import WaveFileReader from './wavefile-reader';
import writeString from './write-string';
import validateNumChannels from './validate-num-channels'; 
import validateSampleRate from './validate-sample-rate';
import {unpack, packTo, packStringTo, packString, pack} from 'byte-data';

/**
 * A class to read and write wav files.
 * @extends WaveFileReader
 */
export default class WaveFileParser extends WaveFileReader {

  /**
   * Return a byte buffer representig the WaveFileParser object as a .wav file.
   * The return value of this method can be written straight to disk.
   * @return {!Uint8Array} A wav file.
   * @throws {Error} If bit depth is invalid.
   * @throws {Error} If the number of channels is invalid.
   * @throws {Error} If the sample rate is invalid.
   */
  toBuffer() {
    this.validateWavHeader();
    return this.writeWavBuffer_();
  }

  /**
   * Return the sample at a given index.
   * @param {number} index The sample index.
   * @return {number} The sample.
   * @throws {Error} If the sample index is off range.
   */
  getSample(index) {
    index = index * (this.dataType.bits / 8);
    if (index + this.dataType.bits / 8 > this.data.samples.length) {
      throw new Error('Range error');
    }
    return unpack(
      this.data.samples.slice(index, index + this.dataType.bits / 8),
      this.dataType);
  }

  /**
   * Set the sample at a given index.
   * @param {number} index The sample index.
   * @param {number} sample The sample.
   * @throws {Error} If the sample index is off range.
   */
  setSample(index, sample) {
    index = index * (this.dataType.bits / 8);
    if (index + this.dataType.bits / 8 > this.data.samples.length) {
      throw new Error('Range error');
    }
    packTo(sample, this.dataType, this.data.samples, index);
  }

  /**
   * Validate the header of the file.
   * @throws {Error} If bit depth is invalid.
   * @throws {Error} If the number of channels is invalid.
   * @throws {Error} If the sample rate is invalid.
   * @ignore
   * @protected
   */
  validateWavHeader() {
    this.validateBitDepth_();
    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {
      throw new Error('Invalid number of channels.');
    }
    if (!validateSampleRate(
        this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {
      throw new Error('Invalid sample rate.');
    }
  }

  /**
   * Return a .wav file byte buffer with the data from the WaveFileParser object.
   * The return value of this method can be written straight to disk.
   * @return {!Uint8Array} The wav file bytes.
   * @private
   */
  writeWavBuffer_() {
    this.uInt16_.be = this.container === 'RIFX';
    this.uInt32_.be = this.uInt16_.be;
    /** @type {!Array&lt;!Array&lt;number>>} */
    let fileBody = [
      this.getJunkBytes_(),
      this.getDs64Bytes_(),
      this.getBextBytes_(),
      this.getFmtBytes_(),
      this.getFactBytes_(),
      packString(this.data.chunkId),
      pack(this.data.samples.length, this.uInt32_),
      this.data.samples,
      this.getCueBytes_(),
      this.getSmplBytes_(),
      this.getLISTBytes_()
    ];
    /** @type {number} */
    let fileBodyLength = 0;
    for (let i=0; i&lt;fileBody.length; i++) {
      fileBodyLength += fileBody[i].length;
    }
    /** @type {!Uint8Array} */
    let file = new Uint8Array(fileBodyLength + 12);
    /** @type {number} */
    let index = 0;
    index = packStringTo(this.container, file, index);
    index = packTo(fileBodyLength + 4, this.uInt32_, file, index);
    index = packStringTo(this.format, file, index);
    for (let i=0; i&lt;fileBody.length; i++) {
      file.set(fileBody[i], index);
      index += fileBody[i].length;
    }
    return file;
  }

  /**
   * Return the bytes of the 'bext' chunk.
   * @private
   */
  getBextBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    this.enforceBext_();
    if (this.bext.chunkId) {
      this.bext.chunkSize = 602 + this.bext.codingHistory.length;
      bytes = bytes.concat(
        packString(this.bext.chunkId),
        pack(602 + this.bext.codingHistory.length, this.uInt32_),
        writeString(this.bext.description, 256),
        writeString(this.bext.originator, 32),
        writeString(this.bext.originatorReference, 32),
        writeString(this.bext.originationDate, 10),
        writeString(this.bext.originationTime, 8),
        pack(this.bext.timeReference[0], this.uInt32_),
        pack(this.bext.timeReference[1], this.uInt32_),
        pack(this.bext.version, this.uInt16_),
        writeString(this.bext.UMID, 64),
        pack(this.bext.loudnessValue, this.uInt16_),
        pack(this.bext.loudnessRange, this.uInt16_),
        pack(this.bext.maxTruePeakLevel, this.uInt16_),
        pack(this.bext.maxMomentaryLoudness, this.uInt16_),
        pack(this.bext.maxShortTermLoudness, this.uInt16_),
        writeString(this.bext.reserved, 180),
        writeString(
          this.bext.codingHistory, this.bext.codingHistory.length));
    }
    return bytes;
  }

  /**
   * Make sure a 'bext' chunk is created if BWF data was created in a file.
   * @private
   */
  enforceBext_() {
    for (let prop in this.bext) {
      if (this.bext.hasOwnProperty(prop)) {
        if (this.bext[prop] &amp;&amp; prop != 'timeReference') {
          this.bext.chunkId = 'bext';
          break;
        }
      }
    }
    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {
      this.bext.chunkId = 'bext';
    }
  }

  /**
   * Return the bytes of the 'ds64' chunk.
   * @return {!Array&lt;number>} The 'ds64' chunk bytes.
   * @private
   */
  getDs64Bytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    if (this.ds64.chunkId) {
      bytes = bytes.concat(
        packString(this.ds64.chunkId),
        pack(this.ds64.chunkSize, this.uInt32_),
        pack(this.ds64.riffSizeHigh, this.uInt32_),
        pack(this.ds64.riffSizeLow, this.uInt32_),
        pack(this.ds64.dataSizeHigh, this.uInt32_),
        pack(this.ds64.dataSizeLow, this.uInt32_),
        pack(this.ds64.originationTime, this.uInt32_),
        pack(this.ds64.sampleCountHigh, this.uInt32_),
        pack(this.ds64.sampleCountLow, this.uInt32_));
    }
    //if (this.ds64.tableLength) {
    //  ds64Bytes = ds64Bytes.concat(
    //    pack(this.ds64.tableLength, this.uInt32_),
    //    this.ds64.table);
    //}
    return bytes;
  }

  /**
   * Return the bytes of the 'cue ' chunk.
   * @return {!Array&lt;number>} The 'cue ' chunk bytes.
   * @private
   */
  getCueBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    if (this.cue.chunkId) {
      /** @type {!Array&lt;number>} */
      let cuePointsBytes = this.getCuePointsBytes_();
      bytes = bytes.concat(
        packString(this.cue.chunkId),
        pack(cuePointsBytes.length + 4, this.uInt32_),
        pack(this.cue.dwCuePoints, this.uInt32_),
        cuePointsBytes);
    }
    return bytes;
  }

  /**
   * Return the bytes of the 'cue ' points.
   * @return {!Array&lt;number>} The 'cue ' points as an array of bytes.
   * @private
   */
  getCuePointsBytes_() {
    /** @type {!Array&lt;number>} */
    let points = [];
    for (let i=0; i&lt;this.cue.dwCuePoints; i++) {
      points = points.concat(
        pack(this.cue.points[i].dwName, this.uInt32_),
        pack(this.cue.points[i].dwPosition, this.uInt32_),
        packString(this.cue.points[i].fccChunk),
        pack(this.cue.points[i].dwChunkStart, this.uInt32_),
        pack(this.cue.points[i].dwBlockStart, this.uInt32_),
        pack(this.cue.points[i].dwSampleOffset, this.uInt32_));
    }
    return points;
  }

  /**
   * Return the bytes of the 'smpl' chunk.
   * @return {!Array&lt;number>} The 'smpl' chunk bytes.
   * @private
   */
  getSmplBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    if (this.smpl.chunkId) {
      /** @type {!Array&lt;number>} */
      let smplLoopsBytes = this.getSmplLoopsBytes_();
      bytes = bytes.concat(
        packString(this.smpl.chunkId),
        pack(smplLoopsBytes.length + 36, this.uInt32_),
        pack(this.smpl.dwManufacturer, this.uInt32_),
        pack(this.smpl.dwProduct, this.uInt32_),
        pack(this.smpl.dwSamplePeriod, this.uInt32_),
        pack(this.smpl.dwMIDIUnityNote, this.uInt32_),
        pack(this.smpl.dwMIDIPitchFraction, this.uInt32_),
        pack(this.smpl.dwSMPTEFormat, this.uInt32_),
        pack(this.smpl.dwSMPTEOffset, this.uInt32_),
        pack(this.smpl.dwNumSampleLoops, this.uInt32_),
        pack(this.smpl.dwSamplerData, this.uInt32_),
        smplLoopsBytes);
    }
    return bytes;
  }

  /**
   * Return the bytes of the 'smpl' loops.
   * @return {!Array&lt;number>} The 'smpl' loops as an array of bytes.
   * @private
   */
  getSmplLoopsBytes_() {
    /** @type {!Array&lt;number>} */
    let loops = [];
    for (let i=0; i&lt;this.smpl.dwNumSampleLoops; i++) {
      loops = loops.concat(
        pack(this.smpl.loops[i].dwName, this.uInt32_),
        pack(this.smpl.loops[i].dwType, this.uInt32_),
        pack(this.smpl.loops[i].dwStart, this.uInt32_),
        pack(this.smpl.loops[i].dwEnd, this.uInt32_),
        pack(this.smpl.loops[i].dwFraction, this.uInt32_),
        pack(this.smpl.loops[i].dwPlayCount, this.uInt32_));
    }
    return loops;
  }

  /**
   * Return the bytes of the 'fact' chunk.
   * @return {!Array&lt;number>} The 'fact' chunk bytes.
   * @private
   */
  getFactBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    if (this.fact.chunkId) {
      bytes = bytes.concat(
        packString(this.fact.chunkId),
        pack(this.fact.chunkSize, this.uInt32_),
        pack(this.fact.dwSampleLength, this.uInt32_));
    }
    return bytes;
  }

  /**
   * Return the bytes of the 'fmt ' chunk.
   * @return {!Array&lt;number>} The 'fmt' chunk bytes.
   * @throws {Error} if no 'fmt ' chunk is present.
   * @private
   */
  getFmtBytes_() {
    /** @type {!Array&lt;number>} */
    let fmtBytes = [];
    if (this.fmt.chunkId) {
      return fmtBytes.concat(
        packString(this.fmt.chunkId),
        pack(this.fmt.chunkSize, this.uInt32_),
        pack(this.fmt.audioFormat, this.uInt16_),
        pack(this.fmt.numChannels, this.uInt16_),
        pack(this.fmt.sampleRate, this.uInt32_),
        pack(this.fmt.byteRate, this.uInt32_),
        pack(this.fmt.blockAlign, this.uInt16_),
        pack(this.fmt.bitsPerSample, this.uInt16_),
        this.getFmtExtensionBytes_());
    }
    throw Error('Could not find the "fmt " chunk');
  }

  /**
   * Return the bytes of the fmt extension fields.
   * @return {!Array&lt;number>} The fmt extension bytes.
   * @private
   */
  getFmtExtensionBytes_() {
    /** @type {!Array&lt;number>} */
    let extension = [];
    if (this.fmt.chunkSize > 16) {
      extension = extension.concat(
        pack(this.fmt.cbSize, this.uInt16_));
    }
    if (this.fmt.chunkSize > 18) {
      extension = extension.concat(
        pack(this.fmt.validBitsPerSample, this.uInt16_));
    }
    if (this.fmt.chunkSize > 20) {
      extension = extension.concat(
        pack(this.fmt.dwChannelMask, this.uInt32_));
    }
    if (this.fmt.chunkSize > 24) {
      extension = extension.concat(
        pack(this.fmt.subformat[0], this.uInt32_),
        pack(this.fmt.subformat[1], this.uInt32_),
        pack(this.fmt.subformat[2], this.uInt32_),
        pack(this.fmt.subformat[3], this.uInt32_));
    }
    return extension;
  }

  /**
   * Return the bytes of the 'LIST' chunk.
   * @return {!Array&lt;number>} The 'LIST' chunk bytes.
   * @private
   */
  getLISTBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    for (let i=0; i&lt;this.LIST.length; i++) {
      /** @type {!Array&lt;number>} */
      let subChunksBytes = this.getLISTSubChunksBytes_(
          this.LIST[i].subChunks, this.LIST[i].format);
      bytes = bytes.concat(
        packString(this.LIST[i].chunkId),
        pack(subChunksBytes.length + 4, this.uInt32_),
        packString(this.LIST[i].format),
        subChunksBytes);
    }
    return bytes;
  }

  /**
   * Return the bytes of the sub chunks of a 'LIST' chunk.
   * @param {!Array&lt;!Object>} subChunks The 'LIST' sub chunks.
   * @param {string} format The format of the 'LIST' chunk.
   *    Currently supported values are 'adtl' or 'INFO'.
   * @return {!Array&lt;number>} The sub chunk bytes.
   * @private
   */
  getLISTSubChunksBytes_(subChunks, format) {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    for (let i=0; i&lt;subChunks.length; i++) {
      if (format == 'INFO') {
        bytes = bytes.concat(
          packString(subChunks[i].chunkId),
          pack(subChunks[i].value.length + 1, this.uInt32_),
          writeString(
            subChunks[i].value, subChunks[i].value.length));
        bytes.push(0);
      } else if (format == 'adtl') {
        if (['labl', 'note'].indexOf(subChunks[i].chunkId) > -1) {
          bytes = bytes.concat(
            packString(subChunks[i].chunkId),
            pack(
              subChunks[i].value.length + 4 + 1, this.uInt32_),
            pack(subChunks[i].dwName, this.uInt32_),
            writeString(
              subChunks[i].value,
              subChunks[i].value.length));
          bytes.push(0);
        } else if (subChunks[i].chunkId == 'ltxt') {
          bytes = bytes.concat(
            this.getLtxtChunkBytes_(subChunks[i]));
        }
      }
      if (bytes.length % 2) {
        bytes.push(0);
      }
    }
    return bytes;
  }

  /**
   * Return the bytes of a 'ltxt' chunk.
   * @param {!Object} ltxt the 'ltxt' chunk.
   * @private
   */
  getLtxtChunkBytes_(ltxt) {
    return [].concat(
      packString(ltxt.chunkId),
      pack(ltxt.value.length + 20, this.uInt32_),
      pack(ltxt.dwName, this.uInt32_),
      pack(ltxt.dwSampleLength, this.uInt32_),
      pack(ltxt.dwPurposeID, this.uInt32_),
      pack(ltxt.dwCountry, this.uInt16_),
      pack(ltxt.dwLanguage, this.uInt16_),
      pack(ltxt.dwDialect, this.uInt16_),
      pack(ltxt.dwCodePage, this.uInt16_),
      writeString(ltxt.value, ltxt.value.length));
  }

  /**
   * Return the bytes of the 'junk' chunk.
   * @private
   */
  getJunkBytes_() {
    /** @type {!Array&lt;number>} */
    let bytes = [];
    if (this.junk.chunkId) {
      return bytes.concat(
        packString(this.junk.chunkId),
        pack(this.junk.chunkData.length, this.uInt32_),
        this.junk.chunkData);
    }
    return bytes;
  }

  /**
   * Validate the bit depth.
   * @return {boolean} True is the bit depth is valid.
   * @throws {Error} If bit depth is invalid.
   * @private
   */
  validateBitDepth_() {
    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {
      if (parseInt(this.bitDepth, 10) > 8 &amp;&amp;
          parseInt(this.bitDepth, 10) &lt; 54) {
        return true;
      }
      throw new Error('Invalid bit depth.');
    }
    return true;
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed Aug 07 2019 14:41:57 GMT-0300 (Hora oficial do Brasil) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
