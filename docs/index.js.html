<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * Wavefile
 * Handle wave files with 8, 16, 24, 32 PCM, 32 IEEE &amp; 64-bit data.
 * Copyright (c) 2017 Rafael da Silva Rocha. MIT License.
 * https://github.com/rochars/wavefile
 *
 */

const byteData = require("byte-data");
const wavefileheader = require("./src/wavefileheader");

/**
 * A wave file.
 */
class WaveFile extends wavefileheader.WaveFileHeader {

    /**
     * @param {Uint8Array} bytes The file bytes.
     * @param {boolean} enforceFact True if it should throw a error
     *      if no "fact" chunk is found.
     * @param {boolean} enforceBext True if it should throw a error
     *      if no "bext" chunk is found.
     */
    constructor(bytes, enforceFact=false, enforceBext=false) {
        super();
        /** @type {boolean} */
        this.isFromScratch_ = false;
        /** @type {boolean} */
        this.enforceFact = enforceFact;
        /** @type {boolean} */
        this.enforceBext = enforceBext;
        /**
         * Error messages.
         * @enum {string}
         */
        this.WaveErrors = {
            "format": "Not a supported format.",
            "wave": "Could not find the 'WAVE' chunk",
            "fmt ": "Could not find the 'fmt ' chunk",
            "data": "Could not find the 'data' chunk",
            "fact": "Could not find the 'fact' chunk",
            "bext": "Could not find the 'bext' chunk",
            "bitDepth": "Invalid bit depth.",
            "numChannels": "Invalid number of channels.",
            "sampleRate": "Invalid sample rate."
        };
        this.samples_ = [];
        this.bytes_ = [];
        if(bytes) {
            this.fromBytes(bytes);
        }
    }

    /**
     * Create a WaveFile object based on the arguments passed.
     * @param {number} numChannels The number of channels
     *     (Ints like 1 for mono, 2 stereo and so on).
     * @param {number} sampleRate The sample rate.
     *     Integer numbers like 8000, 44100, 48000, 96000, 192000.
     * @param {string} bitDepth The audio bit depth.
     *     One of "8", "16", "24", "32", "32f", "64".
     * @param {!Array&lt;number>} samples Array of samples to be written.
     *     Samples must be in the correct range according to the bit depth.
     *     Samples of multi-channel data .
     */
    fromScratch(numChannels, sampleRate, bitDepth, samples) {
        this.isFromScratch_ = true;
        let bytes = parseInt(bitDepth, 10) / 8;
        this.chunkSize = 36 + samples.length * bytes;
        this.subChunk1Size = 16;
        this.byteRate = (numChannels * bytes) * sampleRate;
        this.blockAlign = numChannels * bytes;
        this.chunkId = "RIFF";
        this.format = "WAVE";
        this.subChunk1Id = "fmt ";
        this.audioFormat = this.headerFormats_[bitDepth];
        this.numChannels = numChannels;
        this.sampleRate = sampleRate;
        this.bitsPerSample = parseInt(bitDepth, 10);
        this.subChunk2Id = "data";
        this.subChunk2Size = samples.length * bytes;
        this.samples_ = samples;
        this.bitDepth_ = bitDepth;
    }

    /**
     * Read a wave file from a byte buffer.
     * @param {Uint8Array} bytes The buffer.
     */
    fromBytes(bytes) {
        this.isFromScratch_ = false;
        this.readRIFFChunk_(bytes);
        this.readWAVEChunk_(bytes);
        this.readFmtChunk_(bytes);
        this.readFactChunk_(bytes);
        this.readBextChunk_(bytes);
        this.readDataChunk_(bytes);
    }

    /**
     * Turn the WaveFile object into a byte buffer.
     * @return {Uint8Array}
     */
    toBytes() {
        this.checkWriteInput_(this.numChannels, this.sampleRate, this.bitDepth_);
        this.samplesToBytes_();
        return new Uint8Array(this.createWaveFile_());
    }

    /**
     * Interleave multi-channel samples.
     */
    interleave() {
        let finalSamples = [];
        let i;
        let j;
        let numChannels = this.samples_[0].length;
        for (i = 0; i &lt; numChannels; i++) {
            for (j = 0; j &lt; this.samples_.length; j++) {
                finalSamples.push(this.samples_[j][i]);
            }
        }
        this.samples_ = finalSamples;
    }

    /**
     * De-interleave samples into multiple channels.
     */
    deInterleave() {
        let finalSamples = [];
        let i;
        for (i = 0; i &lt; this.numChannels; i++) {
            finalSamples[i] = [];
        }
        i = 0;
        let j;
        while (i &lt; this.samples_.length) {
            for (j = 0; j &lt; this.numChannels; j++) {
                finalSamples[j].push(this.samples_[i+j]);
            }
            i += j;
        }
        this.samples_ = finalSamples;
    }

    /**
     * Read the RIFF chunk a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "RIFF" chunk is found.
     */
    readRIFFChunk_(bytes) {
        this.chunkId = byteData.fromBytes(bytes.slice(0, 4),
            8, {"char": true});
        if (this.chunkId != "RIFF") {
            throw Error(this.WaveErrors.format);
        }
        this.chunkSize = byteData.fromBytes(
            bytes.slice(4, 8), 32)[0];
    }

    /**
     * Read the WAVE chunk of a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "WAVE" chunk is found.
     */
    readWAVEChunk_(bytes) {
        let start = byteData.findString(bytes, "WAVE");
        if (start === -1) {
            throw Error(this.WaveErrors.wave);
        }
        this.format = "WAVE";
    }

    /**
     * Read the "fmt " chunk of a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "fmt " chunk is found.
     */
    readFmtChunk_(bytes) {
        let start = byteData.findString(bytes, "fmt ");
        if (start === -1) {
            throw Error(this.WaveErrors["fmt "]);
        }
        this.subChunk1Id = "fmt ";
        this.subChunk1Size = byteData.fromBytes(
            bytes.slice(start + 4, start + 8), 32)[0];
        this.audioFormat = byteData.fromBytes(
            bytes.slice(start + 8, start + 10), 16)[0];
        this.numChannels = byteData.fromBytes(
            bytes.slice(start + 10, start + 12), 16)[0];
        this.sampleRate = byteData.fromBytes(
            bytes.slice(start + 12, start + 16), 32)[0];
        this.byteRate = byteData.fromBytes(
            bytes.slice(start + 16, start + 20), 32)[0];
        this.blockAlign = byteData.fromBytes(
            bytes.slice(start + 20, start + 22), 16)[0];
        this.bitsPerSample = byteData.fromBytes(
            bytes.slice(start + 22, start + 24), 16)[0];
        if (this.audioFormat == 3 &amp;&amp; this.bitsPerSample == 32) {
            this.bitDepth_ = "32f";
        }else {
            this.bitDepth_ = this.bitsPerSample.toString();
        }
    }

    /**
     * Read the "fact" chunk of a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "fact" chunk is found.
     */
    readFactChunk_(bytes) {
        let start = byteData.findString(bytes, "fact");
        if (start === -1 &amp;&amp; this.enforceFact) {
            throw Error(this.WaveErrors.fact);
        }else if (start > -1) {
            this.factChunkId = "fact";
            //this.factChunkSize = byteData.uIntFrom4Bytes(
            //    bytes.slice(start + 4, start + 8));
            //this.dwSampleLength = byteData.uIntFrom4Bytes(
            //    bytes.slice(start + 8, start + 12));
        }
    }

    /**
     * Read the "bext" chunk of a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "bext" chunk is found.
     */
    readBextChunk_(bytes) {
        let start = byteData.findString(bytes, "bext");
        if (start === -1 &amp;&amp; this.enforceBext) {
            throw Error(this.WaveErrors.bext);
        }else if (start > -1){
            this.bextChunkId = "bext";
        }
    }

    /**
     * Read the "data" chunk of a wave file.
     * @param {Uint8Array} bytes an array representing the wave file.
     * @throws {Error} If no "data" chunk is found.
     */
    readDataChunk_(bytes) {
        let start = byteData.findString(bytes, "data");
        if (start === -1) {
            throw Error(this.WaveErrors.data);
        }
        this.subChunk2Id = "data";
        this.subChunk2Size = byteData.fromBytes(
            bytes.slice(start + 4, start + 8), 32)[0];
        this.samplesFromBytes_(bytes, start);
    }

    /**
     * Find and return the start offset of the data chunk on a wave file.
     * @param {Uint8Array} bytes Array of bytes representing the wave file.
     * @param {number} start The offset to start reading.
     */
    samplesFromBytes_(bytes, start) {
        let params = {
            "signed": this.bitsPerSample == 8 ? false : true,
        };
        if (this.bitsPerSample == 32 &amp;&amp; this.audioFormat == 3) {
            params.float = true;
        }
        let samples = bytes.slice(start + 8, start + 8 + this.subChunk2Size);
        if (this.bitsPerSample == 4) {
            this.samples_ = byteData.fromBytes(samples, 8, params);
        } else {
            this.samples_ = byteData.fromBytes(samples, this.bitsPerSample, params);
        }
    }

    /**
     * Validate the input for wav writing.
     * @param {number} numChannels The number of channels
     *     Should be a int greater than zero smaller than the
     *     channel limit according to the bit depth.
     * @param {number} sampleRate The sample rate.
     *     Should be a int greater than zero smaller than the
     *     channel limit according to the bit depth and number of channels.
     * @param {string} bitDepth The audio bit depth.
     *     Should be one of "8", "16", "24", "32", "32f", "64".
     * @throws {Error} If any argument does not meet the criteria.
     */
    checkWriteInput_() {
        if (!this.headerFormats_[this.bitDepth_]) {
            throw new Error(this.WaveErrors.bitDepth);
        }
        this.validateNumChannels_();
        this.validateSampleRate_();
    }

    /**
     * Validate the sample rate value.
     * @param {number} numChannels The number of channels
     * @param {string} bitDepth The audio bit depth.
     *     Should be one of "8", "16", "24", "32", "32f", "64".
     * @throws {Error} If any argument does not meet the criteria.
     */
    validateNumChannels_() {
        let blockAlign = this.numChannels * this.bitsPerSample / 8;
        if (this.numChannels &lt; 1 || blockAlign > 65535) {
            throw new Error(this.WaveErrors.numChannels);
        }
        return true;
    }

    /**
     * Validate the sample rate value.
     * @param {number} numChannels The number of channels
     *     Should be a int greater than zero smaller than the
     *     channel limit according to the bit depth.
     * @param {number} sampleRate The sample rate.
     * @param {string} bitDepth The audio bit depth.
     *     Should be one of "8", "16", "24", "32", "32f", "64".
     * @throws {Error} If any argument does not meet the criteria.
     */
    validateSampleRate_() {
        let byteRate = this.numChannels *
            (this.bitsPerSample / 8) * this.sampleRate;
        if (this.sampleRate &lt; 1 || byteRate > 4294967295) {
            throw new Error(this.WaveErrors.sampleRate);
        }
        return true;
    }

    /**
     * Split each sample into bytes.
     */
    samplesToBytes_() {
        let params = {};
        if (this.bitsPerSample == 32 &amp;&amp; this.audioFormat == 3) {
            params.float = true;
        }
        let bitDepth = this.bitsPerSample == 4 ? 8 : this.bitsPerSample;
        this.bytes_ = byteData.toBytes(this.samples_, bitDepth, params);
        if (this.bytes_.length % 2) {
            this.bytes_.push(0);
        }
    }

    /**
     * Turn a WaveFile object into a file.
     * @return {Uint8Array} The wav file bytes.
     */
    createWaveFile_() {
        let factVal = [];
        if (this.factChunkId) {
            factVal = byteData.toBytes(this.factChunkId, 8, {"char": true});
        }
        return byteData.toBytes(this.chunkId, 8, {"char": true}).concat(
            byteData.toBytes([this.chunkSize], 32),
            byteData.toBytes(this.format, 8, {"char": true}), 
            byteData.toBytes(this.subChunk1Id, 8, {"char": true}),
            byteData.toBytes([this.subChunk1Size], 32),
            byteData.toBytes([this.audioFormat], 16),
            byteData.toBytes([this.numChannels], 16),
            byteData.toBytes([this.sampleRate], 32),
            byteData.toBytes([this.byteRate], 32),
            byteData.toBytes([this.blockAlign], 16),
            byteData.toBytes([this.bitsPerSample], 16),
            factVal,
            byteData.toBytes(this.subChunk2Id, 8, {"char": true}),
            byteData.toBytes([this.subChunk2Size], 32),
            this.bytes_);
    }
}

module.exports.WaveFile = WaveFile;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="WaveFile.html">WaveFile</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Nov 24 2017 01:00:33 GMT-0200 (Horário brasileiro de verão)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
