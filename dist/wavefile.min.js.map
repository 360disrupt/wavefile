{"version":3,"sources":["webpack://WaveFile/ [synthetic:util/defineproperty] ","webpack://WaveFile/ [synthetic:util/global] ","webpack://WaveFile/ [synthetic:es6/symbol] ","webpack://WaveFile/ [synthetic:util/polyfill] ","webpack://WaveFile/ [synthetic:es6/object/is] ","webpack://WaveFile/ [synthetic:es6/array/includes] ","webpack://WaveFile/wavefile.min.js","webpack://WaveFile/webpack/bootstrap","webpack://WaveFile/./index.js","webpack://WaveFile/./node_modules/base64-arraybuffer-es6/src/base64-arraybuffer.js","webpack://WaveFile/./node_modules/byte-data/lib/integer.js","webpack://WaveFile/./node_modules/bitdepth/index.js","webpack://WaveFile/./node_modules/endianness/index.js","webpack://WaveFile/./node_modules/byte-data/main.js","webpack://WaveFile/./node_modules/riff-chunks/main.js","webpack://WaveFile/./node_modules/imaadpcm/index.js","webpack://WaveFile/./node_modules/alawmulaw/lib/alaw.js","webpack://WaveFile/./node_modules/alawmulaw/lib/mulaw.js","webpack://WaveFile/./node_modules/byte-data/lib/types.js","webpack://WaveFile/./node_modules/alawmulaw/index.js"],"names":["$jscomp.defineProperty","$jscomp.global","$jscomp.initSymbol","$jscomp.Symbol","$jscomp.SYMBOL_PREFIX","$jscomp.polyfill","window","modules"],"mappings":"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DA,CACA,CADA,EAJA,KAOA,MAEA,cArBA,CA6BA,eAEA,OACA,MACA,SACA,CACA,EADA,IACA,KAFA,CAKA,qBAIA,GADA,KACA,CADA,EACA,CADA,EAEA,CAFA,CAEA,EAFA,GAEA,CAFA,CAEA,CAFA,CAGA,CAHA,EAGA,CAHA,CAGA,CAHA,CAKA,CALA,EAKA,CALA,CAKA,CAGA,WADA,UACA,CApBA,CA4BA,eAGA,IADA,SACA,IAAe,CAAf,CAAe,QAAf,CAAiC,GAAjC,CACA,gBAEA,SANA,CAcA,eAGA,IADA,SACA,IAAe,CAAf;AAAe,QAAf,CAAiC,GAAjC,CACA,gBAEA,SANA,CC1EA,eAEA,SACA,MACA,CACA,CAZA,GAYA,CADA,CACA,MAFA,EAIA,CAJA,EAVA,GAgBA,WACA,CADA,CACA,KADA,CAIA,KAuDA,GACA,OAxDA,CAwDA,GACA,SACA,CACA,GADA,CACA,KAFA,CAIA,QACA,CACA,GADA,CACA,KAFA,CAIA,OACA,CADA,EACA,CADA,CAGA,IAjEA,QADA,CACA,EADA,CACA,CADA,CACA,EADA,CACA,CADA,CACA,CADA,EACA,GAhBA,CAwBA,eACA,IAGA,SADA,CACA,CADA,EACA,GADA,CACA,EAnCA,GAmCA,cACA,cApCA,GAoCA,KApCA,GA+BA,CAaA,eAGA,IADA,SACA,IAAe,CAAf,CAAe,QAAf,CAAiC,GAAjC,CACA,gBAEA,SANA,CAcA,eAGA,IADA,SACA,IAAe,CAAf,CAAe,QAAf,CAAiC,GAAjC,CACA,gBAEA,SANA,CVfA;CAAA,0SIhDA,0BD4DA,gDAGA,KAFA,QACA,eACA,MACA,CACA,EADA,MACA,EADA,CACA,CADA,CACA,IAEA,eACA,yBARA,CAkBA;AAAA,cACA,YACA,aACA,aAAmB,CAAnB,EAAmB,WAAnB,CAAqC,GAArC,CACA,4CAEA,SANA,CAiBA,+CACA,YACA,gBACA,aAAmB,CAAnB,CAAmB,WAAnB,CAAoC,GAApC,CACA,4CAEA,YACA,MADA,CACA,WACA,CADA,CACA,6BADA,CADA,CAGA,MAHA,CAKA,SAXA,CAsBA,6CAGA,KAFA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ACA,YAAiB,CAAjB,CAAiB,gBAAjB,CAAqC,GAArC,CACA,+BACA,QAGA,YANA,CAiBA,2BAGA,IADA,OAAiB,SAAjB,CAAiB,MAAjB,EACA,IAAiB,CAAjB,CAAiB,gBAAjB,CAAqC,GAArC,CACA,gCACA,QACA,aAAqB,CAArB,CAAqB,6BAArB,CAAyD,GAAzD,CACA,yCACA,KACA,MAFA,CAKA,KARA,CAWA,QAfA,CAwBA,2BACA,0BACA;AACK,cACL,YAAmB,CAAnB,CAAmB,CAAnB,CAAmB,QAAnB,CAAmC,GAAnC,CACA,MAGA,SARA,CAoBA,mCACA,OACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CAEA,2CACA,sBACA,uBACA,wBACA,yBACA,kBACA,gCACA,yBACA,sBACA,oDACA,6CAbA,CAyBA,wBACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CACA,OACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CAEA;AAAA,6BACA,sBACA,8CACA,mBACA,2CACA,iCAGA,qDAXA,CAmBA,2BAEA,OAEA,yBACA,CADA,CACA,CADA,CAGK,wBACL,CADK,CACL,CADK,CAGA,wBACL,CADK,CACL,EADK,CAGA,wBACL,CADK,CACL,EADK,CAGA,CAHA,EAGA,oBAHA,GAIL,CAJK,CAIL,IAJK,CAML,SAnBA,CA+BA,wBACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CACA,OACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CACA,CADA,CAEA;AAAA,2BACA,sBACA,kBACA,8BACA,yBACA,sBACA,kDATA,CAqBA,mCACA,QACA,2BACA,6CACA,mBACA,wBACA,sBACA,wBACA,wBACA,gCACA,SADA,CACA,KACA,uBACA;AAAA,CACA,sCACA,kBACA,8BAfA,CAyBA,2BACA,WACA,CADA,CACA,mCADA,CAGA,SAJA,CAYA,0BACA,SACA,UACA,UAHA,CAYA,2BACA,4BACA,CADA,CACA,0BADA,EAEA,EAFA,CAEA,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","file":"wavefile.min.js","sourcesContent":[null,null,null,null,null,null,"/*!\n * wavefile Copyright (c) 2017-2018 Rafael da Silva Rocha.\n * base64-arraybuffer-es6 Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen Licensed under the MIT license.\n */\nwindow[\"WaveFile\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\nvar alaw_namespaceObject = {};\n__webpack_require__.r(alaw_namespaceObject);\n__webpack_require__.d(alaw_namespaceObject, \"encodeSample\", function() { return encodeSample; });\n__webpack_require__.d(alaw_namespaceObject, \"decodeSample\", function() { return decodeSample; });\n__webpack_require__.d(alaw_namespaceObject, \"encode\", function() { return alaw_encode; });\n__webpack_require__.d(alaw_namespaceObject, \"decode\", function() { return alaw_decode; });\nvar mulaw_namespaceObject = {};\n__webpack_require__.r(mulaw_namespaceObject);\n__webpack_require__.d(mulaw_namespaceObject, \"encodeSample\", function() { return mulaw_encodeSample; });\n__webpack_require__.d(mulaw_namespaceObject, \"decodeSample\", function() { return mulaw_decodeSample; });\n__webpack_require__.d(mulaw_namespaceObject, \"encode\", function() { return mulaw_encode; });\n__webpack_require__.d(mulaw_namespaceObject, \"decode\", function() { return mulaw_decode; });\n\n// CONCATENATED MODULE: ./node_modules/bitdepth/index.js\n/*\r\n * bitdepth: Change the resolution of samples to and from any bit depth.\r\n * https://github.com/rochars/bitdepth\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The bitdepth() function and private helper functions.\r\n */\r\n\r\n/** @module bitdepth */\r\n\r\n/** @private */\r\nconst f64f32_ = new Float32Array(1);\r\n\r\n/**\r\n * Change the bit depth of samples. The input array is modified in-place.\r\n * @param {!Array<number>} samples The samples.\r\n * @param {string} original The original bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {string} target The desired bit depth for the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {Array<number>=} outputArray An optional array to write\r\n        converted samples to. Useful for writing to typed arrays.\r\n */\r\nfunction bitdepth(samples, original, target, outputArray) {\r\n  validateBitDepth_(original);\r\n  validateBitDepth_(target);\r\n  outputArray = outputArray || samples;\r\n  /** @type {!Function} */\r\n  let toFunction = getBitDepthFunction_(original, target);\r\n  /** @type {!Object<string, number>} */\r\n  let options = {\r\n    oldMin: Math.pow(2, parseInt(original, 10)) / 2,\r\n    newMin: Math.pow(2, parseInt(target, 10)) / 2,\r\n    oldMax: (Math.pow(2, parseInt(original, 10)) / 2) - 1,\r\n    newMax: (Math.pow(2, parseInt(target, 10)) / 2) - 1,\r\n  };\r\n  /** @type {number} */\r\n  const len = samples.length;\r\n  // sign the samples if original is 8-bit\r\n  if (original == \"8\") {\r\n    for (let i=0; i<len; i++) {\r\n      outputArray[i] = samples[i] -= 128;\r\n    }\r\n  }\r\n  // change the resolution of the samples\r\n  for (let i=0; i<len; i++) {        \r\n    outputArray[i] = toFunction(samples[i], options);\r\n  }\r\n  // unsign the samples if target is 8-bit\r\n  if (target == \"8\") {\r\n    for (let i=0; i<len; i++) {\r\n      outputArray[i] = outputArray[i] += 128;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToInt_(sample, args) {\r\n  if (sample > 0) {\r\n    sample = parseInt((sample / args.oldMax) * args.newMax, 10);\r\n  } else {\r\n    sample = parseInt((sample / args.oldMin) * args.newMin, 10);\r\n  }\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToInt_(sample, args) {\r\n  return parseInt(\r\n    sample > 0 ? sample * args.newMax : sample * args.newMin, 10);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to float.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToFloat_(sample, args) {\r\n  return sample > 0 ? sample / args.oldMax : sample / args.oldMin;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to float.\r\n * @param {number} sample The sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToFloat_(sample) {\r\n  f64f32_[0] = sample;\r\n  return f64f32_[0];\r\n}\r\n\r\n/**\r\n * Return the function to change the bit depth of a sample.\r\n * @param {string} original The original bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {string} target The new bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @return {!Function}\r\n * @private\r\n */\r\nfunction getBitDepthFunction_(original, target) {\r\n  /** @type {!Function} */\r\n  let func = function(x) {return x;};\r\n  if (original != target) {\r\n    if ([\"32f\", \"64\"].includes(original)) {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = floatToFloat_;\r\n      } else {\r\n        func = floatToInt_;\r\n      }\r\n    } else {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = intToFloat_;\r\n      } else {\r\n        func = intToInt_;\r\n      }\r\n    }\r\n  }\r\n  return func;\r\n}\r\n\r\n/**\r\n * Validate the bit depth.\r\n * @param {string} bitDepth The original bit depth.\r\n *     Should be one of \"8\" ... \"53\", \"32f\" or \"64\".\r\n * @throws {Error} If any argument does not meet the criteria.\r\n * @private\r\n */\r\nfunction validateBitDepth_(bitDepth) {\r\n  if ((bitDepth != \"32f\" && bitDepth != \"64\") &&\r\n      (parseInt(bitDepth, 10) < \"8\" || parseInt(bitDepth, 10) > \"53\")) {\r\n    throw new Error(\"Invalid bit depth.\");\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/byte-data/lib/integer.js\n/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Pack and unpack two's complement ints and unsigned ints.\r\n */\r\n\r\n/**\r\n * @module byteData/integer\r\n * @ignore\r\n */\r\n\r\n/**\r\n * A class to pack and unpack two's complement ints and unsigned ints.\r\n * \r\n */\r\nclass Integer {\r\n\r\n  /**\r\n   * @param {number} bits Number of bits used by the data.\r\n   * @param {boolean} signed True for signed types.\r\n   * @throws {Error} if the number of bits is smaller than 1 or greater than 64.\r\n   */\r\n  constructor(bits, signed) {\r\n    /**\r\n     * The max number of bits used by the data.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * If this type it is signed or not.\r\n     * @type {boolean}\r\n     */\r\n    this.signed = signed;\r\n    /**\r\n     * The number of bytes used by the data.\r\n     * @type {number}\r\n     */\r\n    this.offset = 0;\r\n    /**\r\n     * Min value for numbers of this type.\r\n     * @type {number}\r\n     */\r\n    this.min = -Infinity;\r\n    /**\r\n     * Max value for numbers of this type.\r\n     * @type {number}\r\n     */\r\n    this.max = Infinity;\r\n    /**\r\n     * The practical number of bits used by the data.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.realBits_ = this.bits;\r\n    /**\r\n     * The mask to be used in the last byte.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.lastByteMask_ = 255;\r\n    this.build_();\r\n  }\r\n\r\n  /**\r\n   * Read one integer number from a byte buffer.\r\n   * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n   * @param {number=} i The index to read.\r\n   * @return {number}\r\n   */\r\n  read(bytes, i=0) {\r\n    let num = 0;\r\n    let x = this.offset - 1;\r\n    while (x > 0) {\r\n      num = (bytes[x + i] << x * 8) | num;\r\n      x--;\r\n    }\r\n    num = (bytes[i] | num) >>> 0;\r\n    return this.overflow_(this.sign_(num));\r\n  }\r\n\r\n  /**\r\n   * Write one integer number to a byte buffer.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number=} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  write(bytes, number, j=0) {\r\n    number = this.overflow_(number);\r\n    bytes[j++] = number & 255;\r\n    for (let i = 2; i <= this.offset; i++) {\r\n      bytes[j++] = Math.floor(number / Math.pow(2, ((i - 1) * 8))) & 255;\r\n    }\r\n    return j;\r\n  }\r\n\r\n  /**\r\n   * Write one integer number to a byte buffer.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number=} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   * @private\r\n   */\r\n  writeEsoteric_(bytes, number, j=0) {\r\n    number = this.overflow_(number);\r\n    j = this.writeFirstByte_(bytes, number, j);\r\n    for (let i = 2; i < this.offset; i++) {\r\n      bytes[j++] = Math.floor(number / Math.pow(2, ((i - 1) * 8))) & 255;\r\n    }\r\n    if (this.bits > 8) {\r\n      bytes[j++] = Math.floor(\r\n          number / Math.pow(2, ((this.offset - 1) * 8))) &\r\n        this.lastByteMask_;\r\n    }\r\n    return j;\r\n  }\r\n\r\n  /**\r\n   * Read a integer number from a byte buffer by turning int bytes\r\n   * to a string of bits. Used for data with more than 32 bits.\r\n   * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n   * @param {number=} i The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  readBits_(bytes, i=0) {\r\n    let binary = '';\r\n    let j = 0;\r\n    while(j < this.offset) {\r\n      let bits = bytes[i + j].toString(2);\r\n      binary = new Array(9 - bits.length).join('0') + bits + binary;\r\n      j++;\r\n    }\r\n    return this.overflow_(this.sign_(parseInt(binary, 2)));\r\n  }\r\n\r\n  /**\r\n   * Build the type.\r\n   * @throws {Error} if the number of bits is smaller than 1 or greater than 64.\r\n   * @private\r\n   */\r\n  build_() {\r\n    this.setRealBits_();\r\n    this.setLastByteMask_();\r\n    this.setMinMax_();\r\n    this.offset = this.bits < 8 ? 1 : Math.ceil(this.realBits_ / 8);\r\n    if ((this.realBits_ != this.bits) || this.bits < 8 || this.bits > 32) {\r\n      this.write = this.writeEsoteric_;\r\n      this.read = this.readBits_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Limit the value according to the bit depth in case of\r\n   * overflow or underflow.\r\n   * @param {number} value The data.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  overflow_(value) {\r\n    if (value > this.max) {\r\n      throw new Error('Overflow.');\r\n    } else if (value < this.min) {\r\n      throw new Error('Underflow.');\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Set the minimum and maximum values for the type.\r\n   * @private\r\n   */\r\n  setMinMax_() {\r\n    let max = Math.pow(2, this.bits);\r\n    if (this.signed) {\r\n      this.max = max / 2 -1;\r\n      this.min = -max / 2;\r\n    } else {\r\n      this.max = max - 1;\r\n      this.min = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the practical bit number for data with bit count different\r\n   * from the standard types (8, 16, 32, 40, 48, 64) and more than 8 bits.\r\n   * @private\r\n   */\r\n  setRealBits_() {\r\n    if (this.bits > 8) {\r\n      this.realBits_ = ((this.bits - 1) | 7) + 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the mask that should be used when writing the last byte.\r\n   * @private\r\n   */\r\n  setLastByteMask_() {\r\n    let r = 8 - (this.realBits_ - this.bits);\r\n    this.lastByteMask_ = Math.pow(2, r > 0 ? r : 8) -1;\r\n  }\r\n\r\n  /**\r\n   * Write the first byte of a integer number.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   * @private\r\n   */\r\n  writeFirstByte_(bytes, number, j) {\r\n    if (this.bits < 8) {\r\n      bytes[j++] = number < 0 ? number + Math.pow(2, this.bits) : number;\r\n    } else {\r\n      bytes[j++] = number & 255;\r\n    }\r\n    return j;\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/endianness/index.js\n/*\r\n * endianness: Swap endianness in byte arrays.\r\n * https://github.com/rochars/endianness\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A function to swap endianness in byte buffers.\r\n */\r\n\r\n/**\r\n * @module endianness\r\n */\r\n\r\n/**\r\n * Swap the byte ordering in a buffer. The buffer is modified in place.\r\n * @param {!Array<number|string>|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number=} start The start index. Assumes 0.\r\n * @param {?number=} end The end index. Assumes the buffer length.\r\n * @throws {Error} If the buffer length is not valid.\r\n */\r\nfunction endianness(bytes, offset, start=0, end=null) {\r\n    let len = end || bytes.length;\r\n    let limit = parseInt(offset / 2, 10);\r\n    if (len % offset) {\r\n        throw new Error(\"Bad buffer length.\");\r\n    }\r\n    let i = start;\r\n    while (i < len) {\r\n        swap(bytes, offset, i, limit);\r\n        i += offset;\r\n    }\r\n}\r\n\r\n/**\r\n * Swap the byte order of a value in a buffer. The buffer is modified in place.\r\n * @param {!Array<number|string>|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number} index The start index.\r\n * @private\r\n */\r\nfunction swap(bytes, offset, index, limit) {\r\n    let x = 0;\r\n    let y = offset - 1;\r\n    while(x < limit) {\r\n        let theByte = bytes[index + x];\r\n        bytes[index + x] = bytes[index + y];\r\n        bytes[index + y] = theByte;\r\n        x++;\r\n        y--;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/byte-data/lib/types.js\n/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Standard type definitions.\r\n */\r\n\r\n/** @module byteData/types */\r\n\r\n/**\r\n * byte-data standard types.\r\n * @type {!Object}\r\n * @const\r\n */\r\n/* harmony default export */ var types = ({\r\n  /**\r\n   * A char.\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  chr: {'bits': 8, 'char': true},\r\n  /**\r\n   * A 4-char string\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  fourCC: {'bits': 32, 'char': true},\r\n  /**\r\n   * Booleans\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  bool: {'bits': 1},\r\n  /**\r\n   * Signed 2-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int2: {'bits': 2, 'signed': true},\r\n  /**\r\n   * Unsigned 2-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt2: {'bits': 2},\r\n  /**\r\n   * Signed 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int4: {'bits': 4, 'signed': true},\r\n  /**\r\n   * Unsigned 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt4: {'bits': 4},\r\n  /**\r\n   * Signed 8-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int8: {'bits': 8, 'signed': true},\r\n  /**\r\n   * Unsigned 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt8: {'bits': 8},\r\n  // LE\r\n  /**\r\n   * Signed 16-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int16 : {'bits': 16, 'signed': true},\r\n  /**\r\n   * Unsigned 16-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt16: {'bits': 16},\r\n  /**\r\n   * Half-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float16: {'bits': 16, 'float': true},\r\n  /**\r\n   * Signed 24-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int24: {'bits': 24, 'signed': true},\r\n  /**\r\n   * Unsigned 24-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt24: {'bits': 24},\r\n  /**\r\n   * Signed 32-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int32: {'bits': 32, 'signed': true},\r\n  /**\r\n   * Unsigned 32-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt32: {'bits': 32},\r\n  /**\r\n   * Single-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float32: {'bits': 32, 'float': true},\r\n  /**\r\n   * Signed 40-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int40: {'bits': 40, 'signed': true},\r\n  /**\r\n   * Unsigned 40-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt40: {'bits': 40},\r\n  /**\r\n   * Signed 48-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int48: {'bits': 48, 'signed': true},\r\n  /**\r\n   * Unsigned 48-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt48: {'bits': 48},\r\n  /**\r\n   * Double-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float64: {'bits': 64, 'float': true},\r\n  // BE\r\n  /**\r\n   * Signed 16-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int16BE : {'bits': 16, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 16-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt16BE: {'bits': 16, 'be': true},\r\n  /**\r\n   * Half-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float16BE: {'bits': 16, 'float': true, 'be': true},\r\n  /**\r\n   * Signed 24-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int24BE: {'bits': 24, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 24-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt24BE: {'bits': 24, 'be': true},\r\n  /**\r\n   * Signed 32-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int32BE: {'bits': 32, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 32-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt32BE: {'bits': 32, 'be': true},\r\n  /**\r\n   * Single-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float32BE: {'bits': 32, 'float': true, 'be': true},\r\n  /**\r\n   * Signed 40-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int40BE: {'bits': 40, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 40-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt40BE: {'bits': 40, 'be': true},\r\n  /**\r\n   * Signed 48-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int48BE: {'bits': 48, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 48-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt48BE: {'bits': 48, 'be': true},\r\n  /**\r\n   * Double-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float64BE: {'bits': 64, 'float': true, 'be': true},\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/byte-data/main.js\n/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The byte-data API.\r\n */\r\n\r\n/** @module byteData */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Pack a number or a string as a byte buffer.\r\n * @param {number|string} value The value.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nfunction pack(value, theType) {\r\n  setUp_(theType);\r\n  return toBytes_([value], theType);\r\n}\r\n\r\n/**\r\n * Pack an array of numbers or strings to a byte buffer.\r\n * @param {!Array<number|string>|string} values The values.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If any of the values are not valid.\r\n */\r\nfunction packArray(values, theType) {\r\n  setUp_(theType);\r\n  return toBytes_(values, theType);\r\n}\r\n\r\n/**\r\n * Pack a number or a string to a existing byte buffer.\r\n * @param {number|string} value The value.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The output buffer.\r\n * @param {number} index The buffer index to write.\r\n * @return {number} The next index to start writing.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nfunction packTo(value, theType, buffer, index) {\r\n  setUp_(theType);\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  return writeBytes_(value,\r\n    theType,\r\n    buffer,\r\n    index,\r\n    index + theType['offset'],\r\n    validate,\r\n    theType['be']);\r\n}\r\n\r\n/**\r\n * Pack a array of numbers or strings to a existing byte buffer.\r\n * @param {!Array<number|string>} values The value.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The output buffer.\r\n * @param {number} index The buffer index to write.\r\n * @return {number} The next index to start writing.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nfunction packArrayTo(values, theType, buffer, index) {\r\n  setUp_(theType);\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  let be = theType['be'];\r\n  let offset = theType['offset'];\r\n  for (let i=0; i<values.length; i++) {\r\n    index = writeBytes_(\r\n      values[i],\r\n      theType,\r\n      buffer,\r\n      index,\r\n      index + offset,\r\n      validate, be);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a number or a string from a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @return {number|string}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nfunction unpack(buffer, theType) {\r\n  setUp_(theType);\r\n  let values = fromBytes_(\r\n    buffer.slice(0, theType['offset']), theType);\r\n  return values[0];\r\n}\r\n\r\n/**\r\n * Unpack an array of numbers or strings from a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number|string>}\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nfunction unpackArray(buffer, theType) {\r\n  setUp_(theType);\r\n  return fromBytes_(buffer, theType);\r\n}\r\n\r\n/**\r\n * Unpack a number or a string from a byte buffer index.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @param {number=} index The buffer index to read.\r\n * @return {number|string}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nfunction unpackFrom(buffer, theType, index=0) {\r\n  setUp_(theType);\r\n  return readBytes_(buffer, theType, index);\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers strings from a byte buffer index.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @param {number=} start The start index. Assumes 0.\r\n * @param {?number=} end The end index. Assumes the array length.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nfunction unpackArrayFrom(buffer, theType, start=0, end=null) {\r\n  setUp_(theType);\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  let len = end || buffer.length;\r\n  let values = [];\r\n  for (let i=start; i<len; i+=theType['offset']) {\r\n    values.push(reader_(buffer, i));\r\n  }\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  return values;\r\n}\r\n\r\n/**\r\n * @type {!Int8Array}\r\n * @private\r\n */\r\nconst int8_ = new Int8Array(8);\r\n/**\r\n * @type {!Uint32Array}\r\n * @private\r\n */\r\nconst ui32_ = new Uint32Array(int8_.buffer);\r\n/**\r\n * @type {!Float32Array}\r\n * @private\r\n */\r\nconst f32_ = new Float32Array(int8_.buffer);\r\n/**\r\n * @type {!Float64Array}\r\n * @private\r\n */\r\nconst f64_ = new Float64Array(int8_.buffer);\r\n/**\r\n * @type {Function}\r\n * @private\r\n */\r\nlet reader_;\r\n/**\r\n * @type {Function}\r\n * @private\r\n */\r\nlet writer_;\r\n/**\r\n * @type {Object}\r\n * @private\r\n */\r\nlet gInt_ = {};\r\n\r\n/**\r\n * Turn a byte buffer into what the bytes represent.\r\n * @param {!Array<number|string>|!Uint8Array} buffer An array of bytes.\r\n * @param {!Object} theType The type definition.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction readBytes_(buffer, theType, start) {\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset'], start, start + theType['offset']);\r\n  }\r\n  let value = reader_(buffer, start);\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset'], start, start + theType['offset']);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Turn a byte buffer into what the bytes represent.\r\n * @param {!Array<number|string>|!Uint8Array} buffer An array of bytes.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction fromBytes_(buffer, theType) {\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  let len = buffer.length;\r\n  let values = [];\r\n  len = len - (theType['offset'] - 1);\r\n  for (let i=0; i<len; i+=theType['offset']) {\r\n    values.push(reader_(buffer, i));\r\n  }\r\n  return values;\r\n}\r\n\r\n/**\r\n * Turn numbers and strings to bytes.\r\n * @param {!Array<number|string>|string} values The data.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number|string>} the data as a byte buffer.\r\n * @private\r\n */\r\nfunction toBytes_(values, theType) {\r\n  let j = 0;\r\n  let bytes = [];\r\n  let len = values.length;\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  for(let i=0; i < len; i++) {\r\n    validate(values[i], theType);\r\n    j = writer_(bytes, values[i], j);\r\n  }\r\n  if (theType['be']) {\r\n    endianness(bytes, theType['offset']);\r\n  }\r\n  return bytes;\r\n}\r\n\r\n/**\r\n * Turn numbers and strings to bytes.\r\n * @param {number|string} value The value to be packed.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to write the bytes to.\r\n * @param {number} index The index to start writing.\r\n * @param {number} len The end index.\r\n * @param {!Function} validate The function used to validate input.\r\n * @param {boolean} be True if big-endian.\r\n * @return {number} the new index to be written.\r\n * @private\r\n */\r\nfunction writeBytes_(value, theType, buffer, index, len, validate, be) {\r\n  while (index < len) {\r\n    validate(value, theType);\r\n    index = writer_(buffer, value, index);\r\n  }\r\n  if (be) {\r\n    endianness(\r\n      buffer, theType['offset'], index - theType['offset'], index);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Read int values from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction readInt_(bytes, i) {\r\n  return gInt_.read(bytes, i);\r\n}\r\n\r\n/**\r\n * Read 1 16-bit float from bytes.\r\n * Thanks https://stackoverflow.com/a/8796597\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read16F_(bytes, i) {\r\n  let int = gInt_.read(bytes, i);\r\n  let exponent = (int & 0x7C00) >> 10;\r\n  let fraction = int & 0x03FF;\r\n  let floatValue;\r\n  if (exponent) {\r\n    floatValue =  Math.pow(2, exponent - 15) * (1 + fraction / 0x400);\r\n  } else {\r\n    floatValue = 6.103515625e-5 * (fraction / 0x400);\r\n  }\r\n  return floatValue * (int >> 15 ? -1 : 1);\r\n}\r\n\r\n/**\r\n * Read 1 32-bit float from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read32F_(bytes, i) {\r\n  ui32_[0] = gInt_.read(bytes, i);\r\n  return f32_[0];\r\n}\r\n\r\n/**\r\n * Read 1 64-bit float from bytes.\r\n * Thanks https://gist.github.com/kg/2192799\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read64F_(bytes, i) {\r\n  ui32_[0] = gInt_.read(bytes, i);\r\n  ui32_[1] = gInt_.read(bytes, i + 4);\r\n  return f64_[0];\r\n}\r\n\r\n/**\r\n * Read 1 char from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {string}\r\n * @private\r\n */\r\nfunction readChar_(bytes, i) {\r\n  let chrs = '';\r\n  for(let j=0; j < gInt_.offset; j++) {\r\n    chrs += String.fromCharCode(bytes[i+j]);\r\n  }\r\n  return chrs;\r\n}\r\n\r\n/**\r\n * Write a integer value to a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {!number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction writeInt_(bytes, number, j) {\r\n  return gInt_.write(bytes, number, j);\r\n}\r\n\r\n/**\r\n * Write one 16-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write16F_(bytes, number, j) {\r\n  f32_[0] = number;\r\n  let x = ui32_[0];\r\n  let bits = (x >> 16) & 0x8000;\r\n  let m = (x >> 12) & 0x07ff;\r\n  let e = (x >> 23) & 0xff;\r\n  if (e >= 103) {\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n  }\r\n  bytes[j++] = bits & 0xFF;\r\n  bytes[j++] = bits >>> 8 & 0xFF;\r\n  return j;\r\n}\r\n\r\n/**\r\n * Write one 32-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write32F_(bytes, number, j) {\r\n  f32_[0] = number;\r\n  return gInt_.write(bytes, ui32_[0], j);\r\n}\r\n\r\n/**\r\n * Write one 64-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write64F_(bytes, number, j) {\r\n  f64_[0] = number;\r\n  j = gInt_.write(bytes, ui32_[0], j);\r\n  return gInt_.write(bytes, ui32_[1], j);\r\n}\r\n\r\n/**\r\n * Write one char as a byte.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {string} str The string to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction writeChar_(bytes, str, j) {\r\n  for (let i=0; i<str.length; i++) {\r\n    bytes[j++] = str.charCodeAt(i);\r\n  }\r\n  return j;\r\n}\r\n\r\n/**\r\n * Set the function to unpack the data.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction setReader(theType) {\r\n  if (theType['float']) {\r\n    if (theType['bits'] == 16) {\r\n      reader_ = read16F_;\r\n    } else if(theType['bits'] == 32) {\r\n      reader_ = read32F_;\r\n    } else if(theType['bits'] == 64) {\r\n      reader_ = read64F_;\r\n    }\r\n  } else if (theType['char']) {\r\n    reader_ = readChar_;\r\n  } else {\r\n    reader_ = readInt_;\r\n  }\r\n}\r\n\r\n/**\r\n * Set the function to pack the data.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction setWriter(theType) {\r\n  if (theType['float']) {\r\n    if (theType['bits'] == 16) {\r\n      writer_ = write16F_;\r\n    } else if(theType['bits'] == 32) {\r\n      writer_ = write32F_;\r\n    } else if(theType['bits'] == 64) {\r\n      writer_ = write64F_;\r\n    }\r\n  } else if (theType['char']) {\r\n    writer_ = writeChar_;\r\n  } else {\r\n    writer_ = writeInt_;\r\n  }   \r\n}\r\n\r\n/**\r\n * Validate the type and set up the packing/unpacking functions.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction setUp_(theType) {\r\n  validateType_(theType);\r\n  theType['offset'] = theType['bits'] < 8 ? 1 : Math.ceil(theType['bits'] / 8);\r\n  setReader(theType);\r\n  setWriter(theType);\r\n  if (!theType['char']) {\r\n    gInt_ = new Integer(\r\n      theType['bits'] == 64 ? 32 : theType['bits'],\r\n      theType['float'] ? false : theType['signed']);\r\n  } else {\r\n    // Workaround; should not use Integer when type['char']\r\n    gInt_.offset = theType['bits'] < 8 ? 1 : Math.ceil(theType['bits'] / 8);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateType_(theType) {\r\n  if (!theType) {\r\n    throw new Error('Undefined type.');\r\n  }\r\n  if (theType['float']) {\r\n    validateFloatType_(theType);\r\n  } else {\r\n    if (theType['char']) {\r\n      validateCharType_(theType);\r\n    } else {\r\n      validateIntType_(theType);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of floating point numbers.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateFloatType_(theType) {\r\n  if ([16,32,64].indexOf(theType['bits']) == -1) {\r\n    throw new Error('Not a supported float type.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of char and strings.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateCharType_(theType) {\r\n  if (theType['bits'] < 8 || theType['bits'] % 2) {\r\n    throw new Error('Wrong offset for type char.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of integers.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateIntType_(theType) {\r\n  if (theType['bits'] < 1 || theType['bits'] > 53) {\r\n    throw new Error('Not a supported type.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate strings with bad length.\r\n * @param {string|number} value The string to validate.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction validateString_(value, theType) {\r\n  validateNotNull_(value);\r\n  if (value.length > theType['offset']) {\r\n    throw new Error('String is bigger than its type definition.');\r\n  } else if (value.length < theType['offset']) {\r\n    throw new Error('String is smaller than its type definition.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate that the value is not null.\r\n * @param {string|number} value The value.\r\n * @private\r\n */\r\nfunction validateNotNull_(value) {\r\n  if (value === null || value === undefined) {\r\n    throw new Error('Cannot pack null or undefined values.');\r\n  }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/riff-chunks/main.js\n/*\r\n * riff-chunks: Read and write the chunks of RIFF and RIFX files.\r\n * https://github.com/rochars/riff-chunks\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The riff-chunks API and private methods.\r\n */\r\n\r\n/** @module riffChunks */\r\n\r\n\r\n\r\n\r\n/** @private */\r\nconst uInt32_ = {'bits': 32};\r\n/** @private */\r\nconst fourCC_ = {'bits': 32, 'char': true};\r\n/** @type {number} */\r\nlet head_ = 0;\r\n\r\n/**\r\n * Return the indexes of the chunks in a RIFF/RIFX file.\r\n * @param {!Uint8Array|!Array<number>} buffer The file bytes.\r\n * @return {!Object} The RIFF chunks.\r\n */\r\nfunction riffIndex(buffer) {\r\n    head_ = 0;\r\n    let chunkId = getChunkId_(buffer, 0);\r\n    uInt32_['be'] = chunkId == 'RIFX';\r\n    let format = unpackFrom(buffer, fourCC_, 8);\r\n    head_ += 4;\r\n    return {\r\n        'chunkId': chunkId,\r\n        'chunkSize': getChunkSize_(buffer, 0),\r\n        'format': format,\r\n        'subChunks': getSubChunksIndex_(buffer)\r\n    };\r\n}\r\n\r\n/**\r\n * Pack a RIFF/RIFX file.\r\n * @param {!Object} chunks A object like the return of riffChunks.read().\r\n * @param {boolean} list An optional param indicating if the chunk is LIST.\r\n *      'LIST' chunks should not be rendered as Uint8Array.\r\n * @return {!Array<number>|!Uint8Array} The bytes as Uint8Array when chunkId is\r\n *      'RIFF'/'RIFX' or as Array<number> when chunkId is 'LIST'.\r\n */\r\nfunction write(chunks, list=false) {\r\n    uInt32_['be'] = chunks['chunkId'] == 'RIFX';\r\n    let bytes = pack(chunks['chunkId'], fourCC_).concat(\r\n        pack(chunks['chunkSize'], uInt32_),\r\n        pack(chunks['format'], fourCC_),\r\n        writeSubChunks_(chunks['subChunks']));\r\n    if (!list) {\r\n        bytes = new Uint8Array(bytes);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n/**\r\n * Return the chunks of a RIFF/RIFX file.\r\n * @param {!Uint8Array|!Array<number>} buffer The file bytes.\r\n * @return {!Object} The RIFF chunks.\r\n */\r\nfunction read(buffer) {\r\n    buffer = [].slice.call(buffer);\r\n    let chunkId = getChunkId_(buffer, 0);\r\n    uInt32_['be'] = chunkId == 'RIFX';\r\n    let format = unpack(buffer.slice(8, 12), fourCC_);\r\n    let chunkSize = getChunkSize_(buffer, 0);\r\n    let subChunks = getSubChunks_(buffer);\r\n    return {\r\n        'chunkId': chunkId,\r\n        'chunkSize': chunkSize,\r\n        'format': format,\r\n        'subChunks': subChunks\r\n    };\r\n}\r\n\r\n/**\r\n * Return the sub chunks of a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunksIndex_(buffer) {\r\n    let chunks = [];\r\n    let i = head_;\r\n    while(i <= buffer.length - 8) {\r\n        chunks.push(getSubChunkIndex_(buffer, i));\r\n        i += 8 + chunks[chunks.length - 1]['chunkSize'];\r\n        i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n}\r\n\r\n/**\r\n * Return a sub chunk from a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunkIndex_(buffer, index) {\r\n    let chunk = {\r\n        'chunkId': getChunkId_(buffer, index),\r\n        'chunkSize': getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk['chunkId'] == 'LIST') {\r\n        chunk['format'] = unpackFrom(buffer, fourCC_, index + 8);\r\n        head_ += 4;\r\n        chunk['subChunks'] = getSubChunksIndex_(buffer);\r\n    } else {\r\n        let realChunkSize = chunk['chunkSize'] % 2 ?\r\n            chunk['chunkSize'] + 1 : chunk['chunkSize'];\r\n        head_ = index + 8 + realChunkSize;\r\n        chunk['chunkData'] = {\r\n            'start': index + 8,\r\n            'end': head_\r\n        };\r\n    }\r\n    return chunk;\r\n}\r\n\r\n/**\r\n * Pack the sub chunks of a RIFF file.\r\n * @param {!Array<!Object>} chunks The chunks.\r\n * @return {!Array<number>} The chunk bytes.\r\n * @private\r\n */\r\nfunction writeSubChunks_(chunks) {\r\n    let subChunks = [];\r\n    let i = 0;\r\n    while (i < chunks.length) {\r\n        if (chunks[i]['chunkId'] == 'LIST') {\r\n            subChunks = subChunks.concat(write(chunks[i], true));\r\n        } else {\r\n            subChunks = subChunks.concat(\r\n                pack(chunks[i]['chunkId'], fourCC_),\r\n                pack(chunks[i]['chunkSize'], uInt32_),\r\n                chunks[i]['chunkData']);\r\n        }\r\n        i++;\r\n    }\r\n    return subChunks;\r\n}\r\n\r\n/**\r\n * Return the sub chunks of a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunks_(buffer) {\r\n    let chunks = [];\r\n    let i = 12;\r\n    while(i <= buffer.length - 8) {\r\n        chunks.push(getSubChunk_(buffer, i));\r\n        i += 8 + chunks[chunks.length - 1]['chunkSize'];\r\n        i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n}\r\n\r\n/**\r\n * Return a sub chunk from a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunk_(buffer, index) {\r\n    let chunk = {\r\n        'chunkId': getChunkId_(buffer, index),\r\n        'chunkSize': getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk['chunkId'] == 'LIST') {\r\n        chunk['format'] = unpack(\r\n            buffer.slice(index + 8, index + 12), fourCC_);\r\n        chunk['subChunks'] = getSubChunks_(buffer.slice(index));\r\n    } else {\r\n        let slc = chunk['chunkSize'] % 2 ? chunk['chunkSize'] + 1 : chunk['chunkSize'];\r\n        chunk['chunkData'] = buffer.slice(\r\n            index + 8, index + 8 + slc);\r\n    }\r\n    return chunk;\r\n}\r\n\r\n/**\r\n * Return the fourCC_ of a chunk.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {string|number} The id of the chunk.\r\n * @private\r\n */\r\nfunction getChunkId_(buffer, index) {\r\n    head_ += 4;\r\n    return unpackFrom(buffer, fourCC_, index);\r\n}\r\n\r\n/**\r\n * Return the size of a chunk.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {string|number} The size of the chunk without the id and size fields.\r\n * @private\r\n */\r\nfunction getChunkSize_(buffer, index) {\r\n    head_ += 4;\r\n    return unpackFrom(buffer, uInt32_, index + 4);\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/imaadpcm/index.js\n/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * https://github.com/rochars/imaadpcm\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview imaadpcm public API and private methods.\r\n */\r\n\r\n/** @module imaadpcm */\r\n\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst INDEX_TABLE = [\r\n    -1, -1, -1, -1, 2, 4, 6, 8,\r\n    -1, -1, -1, -1, 2, 4, 6, 8];\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst STEP_TABLE = [\r\n    7, 8, 9, 10, 11, 12, 13, 14,\r\n    16, 17, 19, 21, 23, 25, 28, 31,\r\n    34, 37, 41, 45, 50, 55, 60, 66,\r\n    73, 80, 88, 97, 107, 118, 130, 143,\r\n    157, 173, 190, 209, 230, 253, 279, 307,\r\n    337, 371, 408, 449, 494, 544, 598, 658,\r\n    724, 796, 876, 963, 1060, 1166, 1282, 1411,\r\n    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\r\n    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,\r\n    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\r\n    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n    32767];\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderPredicted_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderIndex_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderStep_ = 7;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderPredicted_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderIndex_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderStep_ = 7;\r\n\r\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Array<number>} samples A array of samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction encode(samples) {\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = [];\r\n    /** @type {Array<number>} */\r\n    let block = [];\r\n    for (let i=0; i<samples.length; i++) {\r\n        block.push(samples[i]);\r\n        if ((i % 505 == 0 && i != 0) || i == samples.length - 1) {\r\n            adpcmSamples = adpcmSamples.concat(encodeBlock(block));\r\n            block = [];\r\n        }\r\n    }\r\n    return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Array<number>}\r\n */\r\nfunction decode(adpcmSamples, blockAlign=256) {\r\n    /** @type {!Array<number>} */\r\n    let samples = [];\r\n    /** @type {!Array<number>} */\r\n    let block = [];\r\n    for (let i=0; i<adpcmSamples.length; i++) {\r\n        if (i % blockAlign == 0 && i != 0) {            \r\n            samples = samples.concat(decodeBlock(block));\r\n            block = [];\r\n        }\r\n        block.push(adpcmSamples[i]);\r\n    }\r\n    return samples;\r\n}\r\n\r\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction encodeBlock(block) {\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = blockHead_(block[0]);\r\n    for (let i=3; i<block.length; i+=2) {\r\n        /** @type {number} */\r\n        let sample2 = encodeSample_(block[i]);\r\n        /** @type {number} */\r\n        let sample = encodeSample_(block[i + 1]);\r\n        adpcmSamples.push((sample << 4) | sample2);\r\n    }\r\n    while (adpcmSamples.length < 256) {\r\n        adpcmSamples.push(0);\r\n    }\r\n    return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @return {!Array<number>}\r\n */\r\nfunction decodeBlock(block) {\r\n    decoderPredicted_ = sign_((block[1] << 8) | block[0]);\r\n    decoderIndex_ = block[2];\r\n    decoderStep_ = STEP_TABLE[decoderIndex_];\r\n    /** @type {!Array<number>} */\r\n    let result = [\r\n            decoderPredicted_,\r\n            sign_((block[3] << 8) | block[2])\r\n        ];\r\n    for (let i=4; i<block.length; i++) {\r\n        /** @type {number} */\r\n        let original_sample = block[i];\r\n        /** @type {number} */\r\n        let second_sample = original_sample >> 4;\r\n        /** @type {number} */\r\n        let first_sample = (second_sample << 4) ^ original_sample;\r\n        result.push(decodeSample_(first_sample));\r\n        result.push(decodeSample_(second_sample));\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sign_(num) {\r\n    return num > 32768 ? num - 65536 : num;\r\n}\r\n\r\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction encodeSample_(sample) {\r\n    /** @type {number} */\r\n    let delta = sample - encoderPredicted_;\r\n    /** @type {number} */\r\n    let value = 0;\r\n    if (delta >= 0) {\r\n        value = 0;\r\n    } else {\r\n        value = 8;\r\n        delta = -delta;\r\n    }\r\n    /** @type {number} */\r\n    let step = STEP_TABLE[encoderIndex_];\r\n    /** @type {number} */\r\n    let diff = step >> 3;\r\n    if (delta > step) {\r\n        value |= 4;\r\n        delta -= step;\r\n        diff += step;\r\n    }\r\n    step >>= 1;\r\n    if (delta > step) {\r\n        value |= 2;\r\n        delta -= step;\r\n        diff += step;\r\n    }\r\n    step >>= 1;\r\n    if (delta > step) {\r\n        value |= 1;\r\n        diff += step;\r\n    }\r\n    updateEncoder_(value, diff);\r\n    return value;\r\n}\r\n\r\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @private\r\n */\r\nfunction updateEncoder_(value, diff) {\r\n    if (value & 8) {\r\n        encoderPredicted_ -= diff;\r\n    } else {\r\n        encoderPredicted_ += diff;\r\n    }\r\n    if (encoderPredicted_ < -0x8000) {\r\n        encoderPredicted_ = -0x8000;\r\n    } else if (encoderPredicted_ > 0x7fff) {\r\n        encoderPredicted_ = 0x7fff;\r\n    }\r\n    encoderIndex_ += INDEX_TABLE[value & 7];\r\n    if (encoderIndex_ < 0) {\r\n        encoderIndex_ = 0;\r\n    } else if (encoderIndex_ > 88) {\r\n        encoderIndex_ = 88;\r\n    }\r\n}\r\n\r\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction decodeSample_(nibble) {\r\n    /** @type {number} */\r\n    let difference = 0;\r\n    if (nibble & 4) {\r\n        difference += decoderStep_;\r\n    }\r\n    if (nibble & 2) {\r\n        difference += decoderStep_ >> 1;\r\n    }\r\n    if (nibble & 1) {\r\n        difference += decoderStep_ >> 2;\r\n    }\r\n    difference += decoderStep_ >> 3;\r\n    if (nibble & 8) {\r\n        difference = -difference;\r\n    }\r\n    decoderPredicted_ += difference;\r\n    if (decoderPredicted_ > 32767) {\r\n        decoderPredicted_ = 32767;\r\n    } else if (decoderPredicted_ < -32767) {\r\n        decoderPredicted_ = -32767;\r\n    }\r\n    updateDecoder_(nibble);\r\n    return decoderPredicted_;\r\n}\r\n\r\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @private\r\n */\r\nfunction updateDecoder_(nibble) {\r\n    decoderIndex_ += INDEX_TABLE[nibble];\r\n    if (decoderIndex_ < 0) {\r\n        decoderIndex_ = 0;\r\n    } else if (decoderIndex_ > 88) {\r\n        decoderIndex_ = 88;\r\n    }\r\n    decoderStep_ = STEP_TABLE[decoderIndex_];\r\n}\r\n\r\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction blockHead_(sample) {\r\n    encodeSample_(sample);\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = [];\r\n    adpcmSamples.push(sample & 0xFF);\r\n    adpcmSamples.push((sample >> 8) & 0xFF);\r\n    adpcmSamples.push(encoderIndex_);\r\n    adpcmSamples.push(0);\r\n    return adpcmSamples;\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/alawmulaw/lib/alaw.js\n/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A-Law codec.\r\n * References:\r\n * https://github.com/deftio/companders\r\n * http://dystopiancode.blogspot.com.br/2012/02/pcm-law-and-u-law-companding-algorithms.html\r\n */\r\n\r\n/** @module alawmulaw/alaw */\r\n\r\n/** @type {!Array<number>} */\r\nconst LOG_TABLE = [\r\n  1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, \r\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 \r\n];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit A-Law.\r\n * @param {number} sample A 16-bit linear PCM sample\r\n * @return {number}\r\n */\r\nfunction encodeSample(sample) {\r\n  /** @type {number} */\r\n  let compandedValue; \r\n  sample = (sample ==-32768) ? -32767 : sample;\r\n  /** @type {number} */\r\n  let sign = ((~sample) >> 8) & 0x80; \r\n  if (!sign) {\r\n    sample = sample * -1; \r\n  }\r\n  if (sample > 32635) {\r\n    sample = 32635; \r\n  }\r\n  if (sample >= 256)  {\r\n    /** @type {number} */\r\n    let exponent = LOG_TABLE[(sample >> 8) & 0x7F];\r\n    /** @type {number} */\r\n    let mantissa = (sample >> (exponent + 3) ) & 0x0F; \r\n    compandedValue = ((exponent << 4) | mantissa); \r\n  } else {\r\n    compandedValue = sample >> 4; \r\n  } \r\n  return compandedValue ^ (sign ^ 0x55);\r\n}\r\n\r\n/**\r\n * Decode a 8-bit A-Law sample as 16-bit linear PCM.\r\n * @param {number} aLawSample The 8-bit A-Law sample\r\n * @return {number}\r\n */\r\nfunction decodeSample(aLawSample) {\r\n  /** @type {number} */\r\n  let sign = 0;\r\n  aLawSample ^= 0x55;\r\n  if (aLawSample & 0x80) {\r\n    aLawSample &= ~(1 << 7);\r\n    sign = -1;\r\n  }\r\n  /** @type {number} */\r\n  let position = ((aLawSample & 0xF0) >> 4) + 4;\r\n  /** @type {number} */\r\n  let decoded = 0;\r\n  if (position != 4) {\r\n    decoded = ((1 << position) |\r\n      ((aLawSample & 0x0F) << (position - 4)) |\r\n      (1 << (position - 5)));\r\n  } else {\r\n    decoded = (aLawSample << 1)|1;\r\n  }\r\n  decoded = (sign === 0) ? (decoded) : (-decoded);\r\n  return (decoded * 8) * -1;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit A-Law samples.\r\n * @param {!Array<number>} samples A array of 16-bit PCM samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction alaw_encode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let aLawSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    aLawSamples.push(encodeSample(samples[i]));\r\n  }\r\n  return aLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit A-Law samples into 16-bit linear PCM samples.\r\n * @param {!Array<number>} samples A array of 8-bit A-Law samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction alaw_decode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let pcmSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples.push(decodeSample(samples[i]));\r\n  }\r\n  return pcmSamples;\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/alawmulaw/lib/mulaw.js\n/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview mu-Law codec.\r\n * References:\r\n * https://github.com/torvalds/linux/blob/master/sound/core/oss/mulaw.c\r\n */\r\n\r\n/** @module alawmulaw/mulaw */\r\n\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst BIAS = 0x84;\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit mu-Law.\r\n * @param {number} pcmSample A 16-bit sample\r\n * @return {number}\r\n */\r\nfunction mulaw_encodeSample(pcmSample) {\r\n  /** @type {number} */\r\n  let mask = 0xFF;\r\n  if (pcmSample < 0) {\r\n    pcmSample = BIAS - pcmSample;\r\n    mask = 0x7F;\r\n  } else {\r\n    pcmSample += BIAS;\r\n  }\r\n  if (pcmSample > 0x7FFF) {\r\n    pcmSample = 0x7FFF;\r\n  }\r\n  /** @type {number} */\r\n  let seg = segmentValue_(pcmSample);\r\n  /** @type {number} */\r\n  let uval = (seg << 4) | ((pcmSample >> (seg + 3)) & 0xF);\r\n  return uval ^ mask;\r\n}\r\n\r\n/**\r\n * Decode a 8-bit mu-Law sample as 16-bit linear PCM.\r\n * @param {number} muLawSample The 8-bit mu-Law sample\r\n * @return {number}\r\n */\r\nfunction mulaw_decodeSample(muLawSample) {\r\n  muLawSample = ~muLawSample;\r\n  /** @type {number} */\r\n  let t = ((muLawSample & 0xf) << 3) + BIAS;\r\n  t <<= (muLawSample & 0x70) >> 4;\r\n  return ((muLawSample & 0x80) ? (BIAS - t) : (t - BIAS));\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit mu-Law samples.\r\n * @param {!Array<number>} samples A array of 16-bit linear PCM samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction mulaw_encode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let muLawSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    muLawSamples.push(mulaw_encodeSample(samples[i]));\r\n  }\r\n  return muLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit mu-Law samples into 16-bit linear PCM samples.\r\n * @param {!Array<number>} samples A array of 8-bit mu-Law samples.\r\n * @return {!Array<number>}\r\n */\r\nfunction mulaw_decode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let pcmSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples.push(mulaw_decodeSample(samples[i]));\r\n  }\r\n  return pcmSamples;\r\n}\r\n\r\n/**\r\n * Return the segment value of a PCM sample.\r\n * @param {number} sample\r\n * @return {number}\r\n * @private\r\n */\r\nfunction segmentValue_(sample) {\r\n  /** @type {number} */\r\n  let segment = 0;\r\n  sample >>= 7;\r\n  if (sample & 0xf0) {\r\n    sample >>= 4;\r\n    segment += 4;\r\n  }\r\n  if (sample & 0x0c) {\r\n    sample >>= 2;\r\n    segment += 2;\r\n  }\r\n  if (sample & 0x02) {\r\n    segment += 1;\r\n  }\r\n  return segment;\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/alawmulaw/index.js\n/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The alawmulaw API.\r\n */\r\n\r\n/**\r\n * @module alawmulaw\r\n */\r\n\r\n\r\n\r\n\r\n/* harmony default export */ var alawmulaw = ({\r\n\t/**\r\n\t * @type {!Object}\r\n\t * @export\r\n\t */\r\n\t'alaw': alaw_namespaceObject,\r\n\t/**\r\n\t * @type {!Object}\r\n\t * @export\r\n\t */\r\n\t'mulaw': mulaw_namespaceObject\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/base64-arraybuffer-es6/src/base64-arraybuffer.js\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n// Use a lookup table to find the index.\nconst lookup = new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\n\nconst base64_arraybuffer_encode = function (arraybuffer, byteOffset, length) {\n    const bytes = new Uint8Array(arraybuffer, byteOffset, length),\n        len = bytes.length;\n    let base64 = '';\n\n    for (let i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n\n    return base64;\n};\n\nconst base64_arraybuffer_decode = function (base64) {\n    const len = base64.length;\n\n    let bufferLength = base64.length * 0.75;\n    let p = 0;\n    let encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    const arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (let i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n};\n\n// CONCATENATED MODULE: ./index.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return index_WaveFile; });\n/*\r\n * wavefile: Read and write wave files.\r\n * https://github.com/rochars/wavefile\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFile class.\r\n */\r\n\r\n/** @module wavefile */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @type {!Object}\r\n * @private\r\n */\r\nlet uInt16_ = {'bits': 16};\r\n/**\r\n * @type {!Object}\r\n * @private\r\n */\r\nlet index_uInt32_ = {'bits': 32};\r\n\r\n/**\r\n * Class representing a wav file.\r\n */\r\nclass index_WaveFile {\r\n\r\n  /**\r\n   * @param {?Uint8Array} bytes A wave file buffer.\r\n   * @throws {Error} If no 'RIFF' chunk is found.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  constructor(bytes=null) {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number|string}\r\n     * @export\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * Always 'WAVE'.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.fmt = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'audioFormat': 0,\r\n      /** @export @type {number} */\r\n      'numChannels': 0,\r\n      /** @export @type {number} */\r\n      'sampleRate': 0,\r\n      /** @export @type {number} */\r\n      'byteRate': 0,\r\n      /** @export @type {number} */\r\n      'blockAlign': 0,\r\n      /** @export @type {number} */\r\n      'bitsPerSample': 0,\r\n      /** @export @type {number} */\r\n      'cbSize': 0,\r\n      /** @export @type {number} */\r\n      'validBitsPerSample': 0,\r\n      /** @export @type {number} */\r\n      'dwChannelMask': 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @export @type {!Array<number>}\r\n       */\r\n      'subformat': []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.fact = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwSampleLength': 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.cue = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwCuePoints': 0,\r\n      /** @export @type {!Array<!Object>} */\r\n      'points': [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.smpl = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwManufacturer': 0,\r\n      /** @export @type {number} */\r\n      'dwProduct': 0,\r\n      /** @export @type {number} */\r\n      'dwSamplePeriod': 0,\r\n      /** @export @type {number} */\r\n      'dwMIDIUnityNote': 0,\r\n      /** @export @type {number} */\r\n      'dwMIDIPitchFraction': 0,\r\n      /** @export @type {number} */\r\n      'dwSMPTEFormat': 0,\r\n      /** @export @type {number} */\r\n      'dwSMPTEOffset': 0,\r\n      /** @export @type {number} */\r\n      'dwNumSampleLoops': 0,\r\n      /** @export @type {number} */\r\n      'dwSamplerData': 0,\r\n      /** @export @type {!Array<!Object>} */\r\n      'loops': [],\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.bext = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {string} */\r\n      'description': '', //256\r\n      /** @export @type {string} */\r\n      'originator': '', //32\r\n      /** @export @type {string} */\r\n      'originatorReference': '', //32\r\n      /** @export @type {string} */\r\n      'originationDate': '', //10\r\n      /** @export @type {string} */\r\n      'originationTime': '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @export @type {!Array<number>}\r\n       */\r\n      'timeReference': [0, 0],\r\n      /** @export @type {number} */\r\n      'version': 0, //WORD\r\n      /** @export @type {string} */\r\n      'UMID': '', // 64 chars\r\n      /** @export @type {number} */\r\n      'loudnessValue': 0, //WORD\r\n      /** @export @type {number} */\r\n      'loudnessRange': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxTruePeakLevel': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxMomentaryLoudness': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxShortTermLoudness': 0, //WORD\r\n      /** @export @type {string} */\r\n      'reserved': '', //180\r\n      /** @export @type {string} */\r\n      'codingHistory': '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'riffSizeHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'riffSizeLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'dataSizeHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'dataSizeLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'originationTime': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'sampleCountHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'sampleCountLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @export @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.data = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {!Array<number>} */\r\n      'samples': []\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list must have this signature:\r\n     *  {\r\n     *    'chunkId': '',\r\n     *    'chunkSize': 0,\r\n     *    'format': '',\r\n     *    'subChunks': []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     * @export\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.junk = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {!Array<number>} */\r\n      'chunkData': []\r\n    };\r\n    /**\r\n     * If the data in data.samples is interleaved or not.\r\n     * @type {boolean}\r\n     * @export\r\n     */\r\n    this.isInterleaved = true;\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here will be set to 65534\r\n     * and treated as WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @private\r\n     */\r\n    this.audioFormats_ = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.head_ = 0;\r\n    // Load a file from the buffer if one was passed\r\n    // when creating the object\r\n    if(bytes) {\r\n      this.fromBuffer(bytes);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFile object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepth The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!Array<number>} samples Array of samples to be written.\r\n   *    The samples must be in the correct range according to the\r\n   *    bit depth.\r\n   * @param {?Object} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @export\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepth, samples, options={}) {\r\n    if (!options['container']) {\r\n      options['container'] = 'RIFF';\r\n    }\r\n    this.bitDepth = bitDepth;\r\n    // interleave the samples if they were passed de-interleaved\r\n    this.data.samples = samples;\r\n    if (samples.length > 0) {\r\n      if (samples[0].constructor === Array) {\r\n        this.isInterleaved = false;\r\n        this.assureInterleaved_();\r\n      }\r\n    }\r\n    /** @type {number} */\r\n    let numBytes = (((parseInt(bitDepth, 10) - 1) | 7) + 1) / 8;\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    if (bitDepth == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    } else if (bitDepth == '8a' || bitDepth == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    } else if(Object.keys(this.audioFormats_).indexOf(bitDepth) == -1 ||\r\n        this.fmt.numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    }\r\n    // the data chunk\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length * numBytes;\r\n    this.validateHeader_();\r\n    this.LEorBE_();\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFile object from a byte buffer.\r\n   * @param {!Uint8Array} bytes The buffer.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @export\r\n   */\r\n  fromBuffer(bytes) {\r\n    this.head_ = 0;\r\n    this.clearHeader_();\r\n    this.readRIFFChunk_(bytes);\r\n    /** @type {!Object} */\r\n    let chunk = riffIndex(bytes);\r\n    this.readDs64Chunk_(bytes, chunk['subChunks']);\r\n    this.readFmtChunk_(bytes, chunk['subChunks']);\r\n    this.readFactChunk_(bytes, chunk['subChunks']);\r\n    this.readBextChunk_(bytes, chunk['subChunks']);\r\n    this.readCueChunk_(bytes, chunk['subChunks']);\r\n    this.readSmplChunk_(bytes, chunk['subChunks']);\r\n    this.readDataChunk_(bytes, chunk['subChunks']);\r\n    this.readJunkChunk_(bytes, chunk['subChunks']);\r\n    this.readLISTChunk_(bytes, chunk['subChunks']);\r\n    this.bitDepthFromFmt_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFile object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A .wav file.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toBuffer() {\r\n    this.validateHeader_();\r\n    this.assureInterleaved_();\r\n    return this.createWaveFile_();\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a base64 string to load the WaveFile object.\r\n   * @param {string} base64String A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  fromBase64(base64String) {\r\n    this.fromBuffer(new Uint8Array(base64_arraybuffer_decode(base64String)));\r\n  }\r\n\r\n  /**\r\n   * Return a base64 string representig the WaveFile object as a .wav file.\r\n   * @return {string} A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toBase64() {\r\n    let buffer = this.toBuffer();\r\n    return base64_arraybuffer_encode(buffer, 0, buffer.length);\r\n  }\r\n\r\n  /**\r\n   * Return a DataURI string representig the WaveFile object as a .wav file.\r\n   * The return of this method can be used to load the audio in browsers.\r\n   * @return {string} A .wav file as a DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toDataURI() {\r\n    return 'data:audio/wav;base64,' + this.toBase64();\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a DataURI to load the WaveFile object.\r\n   * @param {string} dataURI A .wav file as DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  fromDataURI(dataURI) {\r\n    this.fromBase64(dataURI.replace('data:audio/wav;base64,', ''));\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   * @export\r\n   */\r\n  toRIFF() {\r\n    if (this.container == 'RF64') {\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        this.bitDepth,\r\n        this.data.samples);\r\n    } else {\r\n      this.container = 'RIFF';\r\n      this.LEorBE_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   * @export\r\n   */\r\n  toRIFX() {\r\n    if (this.container == 'RF64') {\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        this.bitDepth,\r\n        this.data.samples,\r\n        {'container': 'RIFX'});\r\n    } else {\r\n      this.container = 'RIFX';\r\n      this.LEorBE_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean} changeResolution A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   * @export\r\n   */\r\n  toBitDepth(bitDepth, changeResolution=true) {\r\n    let toBitDepth = bitDepth;\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      toBitDepth = this.realBitDepth_(bitDepth);\r\n      thisBitDepth = this.realBitDepth_(this.bitDepth);\r\n    }\r\n    this.assureInterleaved_();\r\n    this.assureUncompressed_();\r\n    this.truncateSamples();\r\n    bitdepth(this.data.samples, thisBitDepth, toBitDepth);\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      bitDepth,\r\n      this.data.samples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Interleave multi-channel samples.\r\n   * @export\r\n   */\r\n  interleave() {\r\n    if (!this.isInterleaved) {\r\n      /** @type {!Array<number>} */\r\n      let finalSamples = [];\r\n      for (let i=0; i < this.data.samples[0].length; i++) {\r\n        for (let j=0; j < this.data.samples.length; j++) {\r\n          finalSamples.push(this.data.samples[j][i]);\r\n        }\r\n      }\r\n      this.data.samples = finalSamples;\r\n      this.isInterleaved = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * De-interleave samples into multiple channels.\r\n   * @export\r\n   */\r\n  deInterleave() {\r\n    if (this.isInterleaved) {\r\n      /** @type {!Array<!Array<number>>} */\r\n      let finalSamples = [];\r\n      for (let i=0; i < this.fmt.numChannels; i++) {\r\n        finalSamples[i] = [];\r\n      }\r\n      /** @type {number} */\r\n      let len = this.data.samples.length;\r\n      for (let i=0; i < len; i+=this.fmt.numChannels) {\r\n        for (let j=0; j < this.fmt.numChannels; j++) {\r\n          finalSamples[j].push(this.data.samples[i+j]);\r\n        }\r\n      }\r\n      this.data.samples = finalSamples;\r\n      this.isInterleaved = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   * @export\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate != 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if(this.fmt.numChannels != 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        encode(this.data.samples),\r\n        {'container': this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromIMAADPCM(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      decode(this.data.samples, this.fmt.blockAlign),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit A-Law.\r\n   * @export\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    this.assureInterleaved_();\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alawmulaw.alaw.encode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromALaw(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alawmulaw.alaw.decode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   * @export\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    this.assureInterleaved_();\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      alawmulaw.mulaw.encode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromMuLaw(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alawmulaw.mulaw.decode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   * @export\r\n   */\r\n  setTag(tag, value) {\r\n    tag = this.fixTagName_(tag);\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST]['subChunks'][index.TAG]['chunkSize'] =\r\n        value.length + 1;\r\n      this.LIST[index.LIST]['subChunks'][index.TAG]['value'] = value;\r\n    } else if (index.LIST !== null) {\r\n      this.LIST[index.LIST]['subChunks'].push({\r\n        'chunkId': tag,\r\n        'chunkSize': value.length + 1,\r\n        'value': value});\r\n    } else {\r\n      this.LIST.push({\r\n        'chunkId': 'LIST',\r\n        'chunkSize': 8 + value.length + 1,\r\n        'format': 'INFO',\r\n        'subChunks': []});\r\n      this.LIST[this.LIST.length - 1]['subChunks'].push({\r\n        'chunkId': tag,\r\n        'chunkSize': value.length + 1,\r\n        'value': value});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   * @export\r\n   */\r\n  getTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      return this.LIST[index.LIST]['subChunks'][index.TAG]['value'];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Remove a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   * @export\r\n   */\r\n  deleteTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST]['subChunks'].splice(index.TAG, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {number} position The cue point position in milliseconds.\r\n   * @param {string} labl The LIST adtl labl text of the marker. Optional.\r\n   * @export\r\n   */\r\n  setCuePoint(position, labl='') {\r\n    this.cue.chunkId = 'cue ';\r\n    position = (position * this.fmt.sampleRate) / 1000;\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n    if (len == 0) {\r\n      this.setCuePoint_(position, 1, labl);\r\n    } else {\r\n      for (let i=0; i<len; i++) {\r\n        if (existingPoints[i]['dwPosition'] > position && !hasSet) {\r\n          this.setCuePoint_(position, i + 1, labl);\r\n          this.setCuePoint_(\r\n            existingPoints[i]['dwPosition'],\r\n            i + 2,\r\n            existingPoints[i]['label']);\r\n          hasSet = true;\r\n        } else {\r\n          this.setCuePoint_(\r\n            existingPoints[i]['dwPosition'],\r\n            i + 1,\r\n            existingPoints[i]['label']);\r\n        }\r\n      }\r\n      if (!hasSet) {\r\n        this.setCuePoint_(position, this.cue.points.length + 1, labl);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   * @export\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i=0; i<len; i++) {\r\n      if (i + 1 != index) {\r\n        this.setCuePoint_(\r\n          existingPoints[i]['dwPosition'],\r\n          i + 1,\r\n          existingPoints[i]['label']);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   * @export\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex !== null) {\r\n      for (let i=0; i<this.LIST[adtlIndex]['subChunks'].length; i++) {\r\n        if (this.LIST[adtlIndex]['subChunks'][i]['dwName'] ==\r\n            pointIndex) {\r\n          this.LIST[adtlIndex]['subChunks'][i]['value'] = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {number} position The position in milliseconds.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(position, dwName, label) {\r\n    this.cue.points.push({\r\n      'dwName': dwName,\r\n      'dwPosition': position,\r\n      'fccChunk': 'data',\r\n      'dwChunkStart': 0,\r\n      'dwBlockStart': 0,\r\n      'dwSampleOffset': position,\r\n    });\r\n    this.setLabl_(dwName, label);\r\n  }\r\n\r\n  /**\r\n   * Return an array with the position of all cue points in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.points.length; i++) {\r\n      points.push({\r\n        'dwPosition': this.cue.points[i]['dwPosition'],\r\n        'label': this.getLabelForCuePoint_(\r\n          this.cue.points[i]['dwName'])});\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the label of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  getLabelForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex !== null) {\r\n      for (let i=0; i<this.LIST[adtlIndex]['subChunks'].length; i++) {\r\n        if (this.LIST[adtlIndex]['subChunks'][i]['dwName'] ==\r\n            pointDwName) {\r\n          return this.LIST[adtlIndex]['subChunks'][i]['value'];\r\n        }\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if (this.LIST[i]['format'] == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @param {string} label The label for the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(dwName, label) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex === null) {\r\n      this.LIST.push({\r\n        'chunkId': 'LIST',\r\n        'chunkSize': 4,\r\n        'format': 'adtl',\r\n        'subChunks': []});\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex === null ? 0 : adtlIndex, dwName, label);\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @param {string} label The label for the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, dwName, label) {\r\n    this.LIST[adtlIndex]['subChunks'].push({\r\n      'chunkId': 'labl',\r\n      'chunkSize': label.length,\r\n      'dwName': dwName,\r\n      'value': label\r\n    });\r\n    this.LIST[adtlIndex]['chunkSize'] += label.length + 4 + 4 + 4 + 1;\r\n  }\r\n\r\n  /**\r\n   * Return the index of the 'adtl' LIST in this.LIST.\r\n   * @return {?number}\r\n   * @private\r\n   */\r\n  getAdtlChunk_() {\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if(this.LIST[i]['format'] == 'adtl') {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\r\n  getTagIndex_(tag) {\r\n    /** @type {!Object<string, ?number>} */\r\n    let index = {LIST: null, TAG: null};\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if (this.LIST[i]['format'] == 'INFO') {\r\n        index.LIST = i;\r\n        for (let j=0; j<this.LIST[i]['subChunks'].length; j++) {\r\n          if (this.LIST[i]['subChunks'][j]['chunkId'] == tag) {\r\n            index.TAG = j;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Fix a RIFF tag format if possible, throw an error otherwise.\r\n   * @param {string} tag The tag name.\r\n   * @return {string} The tag name in proper fourCC format.\r\n   * @private\r\n   */\r\n  fixTagName_(tag) {\r\n    if (tag.constructor !== String) {\r\n      throw new Error('Invalid tag name.');\r\n    } else if(tag.length < 4) {\r\n      for (let i=0; i<4-tag.length; i++) {\r\n        tag += ' ';\r\n      }\r\n    }\r\n    return tag;\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 40 + this.data.samples.length;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact.chunkId = 'fact';\r\n    this.fact.chunkSize = 4;\r\n    this.fact.dwSampleLength = this.data.samples.length * 2;\r\n    this.data.chunkSize = this.data.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 36 + 24 + this.data.samples.length * numBytes;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepth, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepth, 10);\r\n    this.fmt.dwChannelMask = this.getDwChannelMask_();\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Get the value for dwChannelMask according to the number of channels.\r\n   * @return {number} the dwChannelMask value.\r\n   * @private\r\n   */\r\n  getDwChannelMask_() {\r\n    /** @type {number} */\r\n    let dwChannelMask = 0;\r\n    // mono = FC\r\n    if (this.fmt.numChannels == 1) {\r\n      dwChannelMask = 0x4;\r\n    // stereo = FL, FR\r\n    } else if (this.fmt.numChannels == 2) {\r\n      dwChannelMask = 0x3;\r\n    // quad = FL, FR, BL, BR\r\n    } else if (this.fmt.numChannels == 4) {\r\n      dwChannelMask = 0x33;\r\n    // 5.1 = FL, FR, FC, LF, BL, BR\r\n    } else if (this.fmt.numChannels == 6) {\r\n      dwChannelMask = 0x3F;\r\n    // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n    } else if (this.fmt.numChannels == 8) {\r\n      dwChannelMask = 0x63F;\r\n    }\r\n    return dwChannelMask;\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 40 + this.data.samples.length;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact.chunkId = 'fact';\r\n    this.fact.chunkSize = 4;\r\n    this.fact.dwSampleLength = this.data.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.clearHeader_();\r\n    this.container = options['container'];\r\n    this.chunkSize = 36 + this.data.samples.length * numBytes;\r\n    this.format = 'WAVE';\r\n    this.fmt.chunkId = 'fmt ';\r\n    this.fmt.chunkSize = 16;\r\n    this.fmt.byteRate = (numChannels * numBytes) * sampleRate;\r\n    this.fmt.blockAlign = numChannels * numBytes;\r\n    this.fmt.audioFormat = this.audioFormats_[bitDepth] ?\r\n      this.audioFormats_[bitDepth] : 65534;\r\n    this.fmt.numChannels = numChannels;\r\n    this.fmt.sampleRate = sampleRate;\r\n    this.fmt.bitsPerSample = parseInt(bitDepth, 10);\r\n    this.fmt.cbSize = 0;\r\n    this.fmt.validBitsPerSample = 0;\r\n  }\r\n\r\n  /**\r\n   * Return the closest greater number of bits for a number of bits that\r\n   * do not fill a full sequence of bytes.\r\n   * @param {string} bitDepth The bit depth.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  realBitDepth_(bitDepth) {\r\n    if (bitDepth != '32f') {\r\n      bitDepth = (((parseInt(bitDepth, 10) - 1) | 7) + 1).toString();\r\n    }\r\n    return bitDepth;\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @private\r\n   */\r\n  validateHeader_() {\r\n    this.validateBitDepth_();\r\n    this.validateNumChannels_();\r\n    this.validateSampleRate_();\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.audioFormats_[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate the number of channels.\r\n   * @return {boolean} True is the number of channels is valid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @private\r\n   */\r\n  validateNumChannels_() {\r\n    /** @type {number} */\r\n    let blockAlign = this.fmt.numChannels * this.fmt.bitsPerSample / 8;\r\n    if (this.fmt.numChannels < 1 || blockAlign > 65535) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate the sample rate value.\r\n   * @return {boolean} True is the sample rate is valid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @private\r\n   */\r\n  validateSampleRate_() {\r\n    /** @type {number} */\r\n    let byteRate = this.fmt.numChannels *\r\n      (this.fmt.bitsPerSample / 8) * this.fmt.sampleRate;\r\n    if (this.fmt.sampleRate < 1 || byteRate > 4294967295) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Reset attributes that should emptied when a file is\r\n   * created with the fromScratch() or fromBuffer() methods.\r\n   * @private\r\n   */\r\n  clearHeader_() {\r\n    this.fmt.cbSize = 0;\r\n    this.fmt.validBitsPerSample = 0;\r\n    this.fact.chunkId = '';\r\n    this.ds64.chunkId = '';\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if(this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Interleave the samples in case they are de-Interleaved.\r\n   * @private\r\n   */\r\n  assureInterleaved_() {\r\n    if (!this.isInterleaved) {\r\n      this.interleave();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up to work wih big-endian or little-endian files.\r\n   * The types used are changed to LE or BE. If the\r\n   * the file is big-endian (RIFX), true is returned.\r\n   * @return {boolean} True if the file is RIFX.\r\n   * @private\r\n   */\r\n  LEorBE_() {\r\n    /** @type {boolean} */\r\n    let bigEndian = this.container === 'RIFX';\r\n    uInt16_['be'] = bigEndian;\r\n    index_uInt32_['be'] = bigEndian;\r\n    return bigEndian;\r\n  }\r\n\r\n  /**\r\n   * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n   * @param {!Object} chunks The wav file chunks.\r\n   * @param {string} chunkId The chunk fourCC_.\r\n   * @param {boolean} multiple True if there may be multiple chunks\r\n   *    with the same chunkId.\r\n   * @return {Object|Array<!Object>|null}\r\n   * @private\r\n   */\r\n  findChunk_(chunks, chunkId, multiple=false) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i]['chunkId'] == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read the RIFF chunk a wave file.\r\n   * @param {!Uint8Array} bytes A wav buffer.\r\n   * @throws {Error} If no 'RIFF' chunk is found.\r\n   * @private\r\n   */\r\n  readRIFFChunk_(bytes) {\r\n    this.head_ = 0;\r\n    this.container = this.readString_(bytes, 4);\r\n    if (['RIFF', 'RIFX', 'RF64'].indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.LEorBE_();\r\n    this.chunkSize = this.read_(bytes, index_uInt32_);\r\n    this.format = this.readString_(bytes, 4);\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'fmt ');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.fmt.chunkId = chunk['chunkId'];\r\n      this.fmt.chunkSize = chunk['chunkSize'];\r\n      this.fmt.audioFormat = this.read_(buffer, uInt16_);\r\n      this.fmt.numChannels = this.read_(buffer, uInt16_);\r\n      this.fmt.sampleRate = this.read_(buffer, index_uInt32_);\r\n      this.fmt.byteRate = this.read_(buffer, index_uInt32_);\r\n      this.fmt.blockAlign = this.read_(buffer, uInt16_);\r\n      this.fmt.bitsPerSample = this.read_(buffer, uInt16_);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.read_(buffer, uInt16_);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.read_(buffer, uInt16_);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.read_(buffer, index_uInt32_);\r\n          this.fmt.subformat = [\r\n            this.read_(buffer, index_uInt32_),\r\n            this.read_(buffer, index_uInt32_),\r\n            this.read_(buffer, index_uInt32_),\r\n            this.read_(buffer, index_uInt32_)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'fact');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.fact.chunkId = chunk['chunkId'];\r\n      this.fact.chunkSize = chunk['chunkSize'];\r\n      this.fact.dwSampleLength = this.read_(buffer, index_uInt32_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'cue ');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.cue.chunkId = chunk['chunkId'];\r\n      this.cue.chunkSize = chunk['chunkSize'];\r\n      this.cue.dwCuePoints = this.read_(buffer, index_uInt32_);\r\n      for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          'dwName': this.read_(buffer, index_uInt32_),\r\n          'dwPosition': this.read_(buffer, index_uInt32_),\r\n          'fccChunk': this.readString_(buffer, 4),\r\n          'dwChunkStart': this.read_(buffer, index_uInt32_),\r\n          'dwBlockStart': this.read_(buffer, index_uInt32_),\r\n          'dwSampleOffset': this.read_(buffer, index_uInt32_),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'smpl');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.smpl.chunkId = chunk['chunkId'];\r\n      this.smpl.chunkSize = chunk['chunkSize'];\r\n      this.smpl.dwManufacturer = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwProduct = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwSamplePeriod = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwMIDIUnityNote = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwMIDIPitchFraction = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwSMPTEFormat = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwSMPTEOffset = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwNumSampleLoops = this.read_(buffer, index_uInt32_);\r\n      this.smpl.dwSamplerData = this.read_(buffer, index_uInt32_);\r\n      for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          'dwName': this.read_(buffer, index_uInt32_),\r\n          'dwType': this.read_(buffer, index_uInt32_),\r\n          'dwStart': this.read_(buffer, index_uInt32_),\r\n          'dwEnd': this.read_(buffer, index_uInt32_),\r\n          'dwFraction': this.read_(buffer, index_uInt32_),\r\n          'dwPlayCount': this.read_(buffer, index_uInt32_),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk['chunkSize'];\r\n      this.samplesFromBytes_(buffer, chunk);\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'bext');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.bext.chunkId = chunk['chunkId'];\r\n      this.bext.chunkSize = chunk['chunkSize'];\r\n      this.bext.description = this.readString_(buffer, 256);\r\n      this.bext.originator = this.readString_(buffer, 32);\r\n      this.bext.originatorReference = this.readString_(buffer, 32);\r\n      this.bext.originationDate = this.readString_(buffer, 10);\r\n      this.bext.originationTime = this.readString_(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.read_(buffer, index_uInt32_),\r\n        this.read_(buffer, index_uInt32_)];\r\n      this.bext.version = this.read_(buffer, uInt16_);\r\n      this.bext.UMID = this.readString_(buffer, 64);\r\n      this.bext.loudnessValue = this.read_(buffer, uInt16_);\r\n      this.bext.loudnessRange = this.read_(buffer, uInt16_);\r\n      this.bext.maxTruePeakLevel = this.read_(buffer, uInt16_);\r\n      this.bext.maxMomentaryLoudness = this.read_(buffer, uInt16_);\r\n      this.bext.maxShortTermLoudness = this.read_(buffer, uInt16_);\r\n      this.bext.reserved = this.readString_(buffer, 180);\r\n      this.bext.codingHistory = this.readString_(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'ds64');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.ds64.chunkId = chunk['chunkId'];\r\n      this.ds64.chunkSize = chunk['chunkSize'];\r\n      this.ds64.riffSizeHigh = this.read_(buffer, index_uInt32_);\r\n      this.ds64.riffSizeLow = this.read_(buffer, index_uInt32_);\r\n      this.ds64.dataSizeHigh = this.read_(buffer, index_uInt32_);\r\n      this.ds64.dataSizeLow = this.read_(buffer, index_uInt32_);\r\n      this.ds64.originationTime = this.read_(buffer, index_uInt32_);\r\n      this.ds64.sampleCountHigh = this.read_(buffer, index_uInt32_);\r\n      this.ds64.sampleCountLow = this.read_(buffer, index_uInt32_);\r\n      //if (this.ds64.chunkSize > 28) {\r\n      //  this.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  this.ds64.table = chunkData.slice(\r\n      //     32, 32 + this.ds64.tableLength); \r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');  \r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk_(signature, 'LIST', true);\r\n    if (listChunks === null) {\r\n      return;\r\n    }\r\n    for (let j=0; j < listChunks.length; j++) {\r\n      /** @type {!Object} */\r\n      let subChunk = listChunks[j];\r\n      this.LIST.push({\r\n        'chunkId': subChunk['chunkId'],\r\n        'chunkSize': subChunk['chunkSize'],\r\n        'format': subChunk['format'],\r\n        'subChunks': []});\r\n      for (let x=0; x<subChunk['subChunks'].length; x++) {\r\n        this.readLISTSubChunks_(subChunk['subChunks'][x],\r\n          subChunk['format'], buffer);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk['chunkId']) > -1) {\r\n        this.head_ = subChunk['chunkData']['start'];\r\n        /** @type {!Object<string, string|number>} */\r\n        let item = {\r\n          'chunkId': subChunk['chunkId'],\r\n          'chunkSize': subChunk['chunkSize'],\r\n          'dwName': this.read_(buffer, index_uInt32_)\r\n        };\r\n        if (subChunk['chunkId'] == 'ltxt') {\r\n          item['dwSampleLength'] = this.read_(buffer, index_uInt32_);\r\n          item['dwPurposeID'] = this.read_(buffer, index_uInt32_);\r\n          item['dwCountry'] = this.read_(buffer, uInt16_);\r\n          item['dwLanguage'] = this.read_(buffer, uInt16_);\r\n          item['dwDialect'] = this.read_(buffer, uInt16_);\r\n          item['dwCodePage'] = this.read_(buffer, uInt16_);\r\n        }\r\n        item['value'] = this.readZSTR_(buffer, this.head_);\r\n        this.LIST[this.LIST.length - 1]['subChunks'].push(item);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.head_ = subChunk['chunkData']['start'];\r\n      this.LIST[this.LIST.length - 1]['subChunks'].push({\r\n        'chunkId': subChunk['chunkId'],\r\n        'chunkSize': subChunk['chunkSize'],\r\n        'value': this.readZSTR_(buffer,  this.head_)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        'chunkId': chunk['chunkId'],\r\n        'chunkSize': chunk['chunkSize'],\r\n        'chunkData': [].slice.call(buffer.slice(\r\n          chunk['chunkData']['start'],\r\n          chunk['chunkData']['end']))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Array<number>|!Uint8Array} bytes The bytes.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    for (let i=index; i<bytes.length; i++) {\r\n      this.head_++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n      str += unpackFrom(bytes, types.chr, i);\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Array<number>|!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readString_(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    for (let i=0; i<maxSize; i++) {\r\n      str += unpackFrom(bytes, types.chr, this.head_);\r\n      this.head_++;\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Array<number>|!Uint8Array} bytes The chunk bytes.\r\n   * @param {!Object} bdType The type definition.\r\n   * @return {number|string} The number.\r\n   * @private\r\n   */\r\n  read_(bytes, bdType) {\r\n    /** @type {number} */\r\n    let size = bdType['bits'] / 8;\r\n    /** @type {number|string} */\r\n    let value = unpackFrom(bytes, bdType, this.head_);\r\n    this.head_ += size;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Write a variable size string as bytes. If the string is smaller\r\n   * than the max size the output array is filled with 0s.\r\n   * @param {string} str The string to be written as bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {!Array<number>} The bytes.\r\n   * @private\r\n   */\r\n  writeString_(str, maxSize, push=true) {\r\n    /** @type {!Array<number>} */   \r\n    let bytes = packArray(str, types.chr);\r\n    if (push) {\r\n      for (let i=bytes.length; i<maxSize; i++) {\r\n        bytes.push(0);\r\n      }  \r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Turn the samples to bytes.\r\n   * @return {!Array<number>} The bytes.\r\n   * @private\r\n   */\r\n  samplesToBytes_() {\r\n    return packArray(\r\n      this.data.samples, this.getSamplesType_());\r\n  }\r\n\r\n  /**\r\n   * Truncate float samples on over and underflow.\r\n   * @private\r\n   */\r\n  truncateSamples() {\r\n    if (this.fmt.audioFormat == 3) {\r\n      /** @type {number} */   \r\n      let len = this.data.samples.length;\r\n      for (let i=0; i<len; i++) {\r\n        if (this.data.samples[i] > 1) {\r\n          this.data.samples[i] = 1;\r\n        } else if (this.data.samples[i] < -1) {\r\n          this.data.samples[i] = -1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn bytes to samples and load them in the data.samples property.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @private\r\n   */\r\n  samplesFromBytes_(bytes, chunkData) {\r\n    this.data.samples = unpackArrayFrom(\r\n      bytes,\r\n      this.getSamplesType_(),\r\n      chunkData['chunkData']['start'],\r\n      chunkData['chunkData']['end']);\r\n  }\r\n\r\n  /**\r\n   * Get the data type definition for the samples.\r\n   * @return {!Object<string, number|boolean>} The type definition.\r\n   * @private\r\n   */\r\n  getSamplesType_() {\r\n    /** @type {!Object<string, number|boolean>} */\r\n    let bdType = {\r\n      'be': this.container === 'RIFX',\r\n      'bits': this.fmt.bitsPerSample == 4 ? 8 : this.fmt.bitsPerSample,\r\n      'float': this.fmt.audioFormat == 3 ? true : false\r\n    };\r\n    bdType['signed'] = bdType['bits'] == 8 ? false : true;\r\n    return bdType;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @return {!Array<number>} The 'bext' chunk bytes.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.bext.chunkId, types.fourCC),\r\n        pack(602 + this.bext.codingHistory.length, index_uInt32_),\r\n        this.writeString_(this.bext.description, 256),\r\n        this.writeString_(this.bext.originator, 32),\r\n        this.writeString_(this.bext.originatorReference, 32),\r\n        this.writeString_(this.bext.originationDate, 10),\r\n        this.writeString_(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], index_uInt32_),\r\n        pack(this.bext.timeReference[1], index_uInt32_),\r\n        pack(this.bext.version, uInt16_),\r\n        this.writeString_(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, uInt16_),\r\n        pack(this.bext.loudnessRange, uInt16_),\r\n        pack(this.bext.maxTruePeakLevel, uInt16_),\r\n        pack(this.bext.maxMomentaryLoudness, uInt16_),\r\n        pack(this.bext.maxShortTermLoudness, uInt16_),\r\n        this.writeString_(this.bext.reserved, 180),\r\n        this.writeString_(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (var prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.ds64.chunkId, types.fourCC),\r\n        pack(this.ds64.chunkSize, index_uInt32_),\r\n        pack(this.ds64.riffSizeHigh, index_uInt32_),\r\n        pack(this.ds64.riffSizeLow, index_uInt32_),\r\n        pack(this.ds64.dataSizeHigh, index_uInt32_),\r\n        pack(this.ds64.dataSizeLow, index_uInt32_),\r\n        pack(this.ds64.originationTime, index_uInt32_),\r\n        pack(this.ds64.sampleCountHigh, index_uInt32_),\r\n        pack(this.ds64.sampleCountLow, index_uInt32_));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, uInt32_),\r\n    //    this.ds64.table);\r\n    //}\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        pack(this.cue.chunkId, types.fourCC),\r\n        pack(cuePointsBytes.length + 4, index_uInt32_),\r\n        pack(this.cue.dwCuePoints, index_uInt32_),\r\n        cuePointsBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i]['dwName'], index_uInt32_),\r\n        pack(this.cue.points[i]['dwPosition'], index_uInt32_),\r\n        pack(this.cue.points[i]['fccChunk'], types.fourCC),\r\n        pack(this.cue.points[i]['dwChunkStart'], index_uInt32_),\r\n        pack(this.cue.points[i]['dwBlockStart'], index_uInt32_),\r\n        pack(this.cue.points[i]['dwSampleOffset'], index_uInt32_));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        pack(this.smpl.chunkId, types.fourCC),\r\n        pack(smplLoopsBytes.length + 36, index_uInt32_),\r\n        pack(this.smpl.dwManufacturer, index_uInt32_),\r\n        pack(this.smpl.dwProduct, index_uInt32_),\r\n        pack(this.smpl.dwSamplePeriod, index_uInt32_),\r\n        pack(this.smpl.dwMIDIUnityNote, index_uInt32_),\r\n        pack(this.smpl.dwMIDIPitchFraction, index_uInt32_),\r\n        pack(this.smpl.dwSMPTEFormat, index_uInt32_),\r\n        pack(this.smpl.dwSMPTEOffset, index_uInt32_),\r\n        pack(this.smpl.dwNumSampleLoops, index_uInt32_),\r\n        pack(this.smpl.dwSamplerData, index_uInt32_),\r\n        smplLoopsBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i]['dwName'], index_uInt32_),\r\n        pack(this.smpl.loops[i]['dwType'], index_uInt32_),\r\n        pack(this.smpl.loops[i]['dwStart'], index_uInt32_),\r\n        pack(this.smpl.loops[i]['dwEnd'], index_uInt32_),\r\n        pack(this.smpl.loops[i]['dwFraction'], index_uInt32_),\r\n        pack(this.smpl.loops[i]['dwPlayCount'], index_uInt32_));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.fact.chunkId, types.fourCC),\r\n        pack(this.fact.chunkSize, index_uInt32_),\r\n        pack(this.fact.dwSampleLength, index_uInt32_));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    if (this.fmt.chunkId) {\r\n      return [].concat(\r\n        pack(this.fmt.chunkId, types.fourCC),\r\n        pack(this.fmt.chunkSize, index_uInt32_),\r\n        pack(this.fmt.audioFormat, uInt16_),\r\n        pack(this.fmt.numChannels, uInt16_),\r\n        pack(this.fmt.sampleRate, index_uInt32_),\r\n        pack(this.fmt.byteRate, index_uInt32_),\r\n        pack(this.fmt.blockAlign, uInt16_),\r\n        pack(this.fmt.bitsPerSample, uInt16_),\r\n        this.getFmtExtensionBytes_());\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, uInt16_));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, uInt16_));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, index_uInt32_));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], index_uInt32_),\r\n        pack(this.fmt.subformat[1], index_uInt32_),\r\n        pack(this.fmt.subformat[2], index_uInt32_),\r\n        pack(this.fmt.subformat[3], index_uInt32_));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @export for tests\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i]['subChunks'], this.LIST[i]['format']);\r\n      bytes = bytes.concat(\r\n        pack(this.LIST[i]['chunkId'], types.fourCC),\r\n        pack(subChunksBytes.length + 4, index_uInt32_),\r\n        pack(this.LIST[i]['format'], types.fourCC),\r\n        subChunksBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<subChunks.length; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(\r\n          pack(subChunks[i]['chunkId'], types.fourCC),\r\n          pack(subChunks[i]['value'].length + 1, index_uInt32_),\r\n          this.writeString_(\r\n            subChunks[i]['value'], subChunks[i]['value'].length));\r\n        bytes.push(0);\r\n      } else if (format == 'adtl') {\r\n        if (['labl', 'note'].indexOf(subChunks[i]['chunkId']) > -1) {\r\n          bytes = bytes.concat(\r\n            pack(subChunks[i]['chunkId'], types.fourCC),\r\n            pack(\r\n              subChunks[i]['value'].length + 4 + 1, index_uInt32_),\r\n            pack(subChunks[i]['dwName'], index_uInt32_),\r\n            this.writeString_(\r\n              subChunks[i]['value'],\r\n              subChunks[i]['value'].length));\r\n          bytes.push(0);\r\n        } else if (subChunks[i]['chunkId'] == 'ltxt') {\r\n          bytes = bytes.concat(\r\n            this.getLtxtChunkBytes_(subChunks[i]));\r\n        }\r\n      }\r\n      if (bytes.length % 2) {\r\n        bytes.push(0);\r\n      }\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>} The 'ltxt' chunk bytes.\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      pack(ltxt['chunkId'], types.fourCC),\r\n      pack(ltxt['value'].length + 20, index_uInt32_),\r\n      pack(ltxt['dwName'], index_uInt32_),\r\n      pack(ltxt['dwSampleLength'], index_uInt32_),\r\n      pack(ltxt['dwPurposeID'], index_uInt32_),\r\n      pack(ltxt['dwCountry'], uInt16_),\r\n      pack(ltxt['dwLanguage'], uInt16_),\r\n      pack(ltxt['dwLanguage'], uInt16_),\r\n      pack(ltxt['dwCodePage'], uInt16_),\r\n      this.writeString_(ltxt['value'], ltxt['value'].length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @return {!Array<number>} The 'junk' chunk bytes.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        pack(this.junk.chunkId, types.fourCC),\r\n        pack(this.junk.chunkData.length, index_uInt32_),\r\n        this.junk.chunkData);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat == 3 && this.fmt.bitsPerSample == 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat == 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat == 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a .wav file byte buffer with the data from the WaveFile object.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} The wav file bytes.\r\n   * @private\r\n   */\r\n  createWaveFile_() {\r\n    /** @type {!Array<number>} */\r\n    let samplesBytes = this.samplesToBytes_();\r\n    /** @type {!Array<number>} */\r\n    let fileBody = [].concat(\r\n      pack(this.format, types.fourCC),\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      pack(this.data.chunkId, types.fourCC),\r\n      pack(samplesBytes.length, index_uInt32_),\r\n      samplesBytes,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_());\r\n    return new Uint8Array([].concat(\r\n      pack(this.container, types.fourCC),\r\n      pack(fileBody.length, index_uInt32_),\r\n      fileBody));      \r\n  }\r\n}\r\n\n\n/***/ })\n/******/ ]);"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*\r\n * wavefile: Read and write wave files.\r\n * https://github.com/rochars/wavefile\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFile class.\r\n */\r\n\r\n/** @module wavefile */\r\n\r\nimport bitdepth from 'bitdepth';\r\nimport {riffIndex} from 'riff-chunks';\r\nimport {decode as decodeADPCM, encode as encodeADPCM} from 'imaadpcm';\r\nimport alawmulaw from 'alawmulaw';\r\nimport {encode, decode} from 'base64-arraybuffer-es6';\r\nimport {pack, packArray, unpackFrom,\r\n  unpackArrayFrom, types} from 'byte-data';\r\n\r\n/**\r\n * @type {!Object}\r\n * @private\r\n */\r\nlet uInt16_ = {'bits': 16};\r\n/**\r\n * @type {!Object}\r\n * @private\r\n */\r\nlet uInt32_ = {'bits': 32};\r\n\r\n/**\r\n * Class representing a wav file.\r\n */\r\nexport default class WaveFile {\r\n\r\n  /**\r\n   * @param {?Uint8Array} bytes A wave file buffer.\r\n   * @throws {Error} If no 'RIFF' chunk is found.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  constructor(bytes=null) {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number|string}\r\n     * @export\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * Always 'WAVE'.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.fmt = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'audioFormat': 0,\r\n      /** @export @type {number} */\r\n      'numChannels': 0,\r\n      /** @export @type {number} */\r\n      'sampleRate': 0,\r\n      /** @export @type {number} */\r\n      'byteRate': 0,\r\n      /** @export @type {number} */\r\n      'blockAlign': 0,\r\n      /** @export @type {number} */\r\n      'bitsPerSample': 0,\r\n      /** @export @type {number} */\r\n      'cbSize': 0,\r\n      /** @export @type {number} */\r\n      'validBitsPerSample': 0,\r\n      /** @export @type {number} */\r\n      'dwChannelMask': 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @export @type {!Array<number>}\r\n       */\r\n      'subformat': []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.fact = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwSampleLength': 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.cue = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwCuePoints': 0,\r\n      /** @export @type {!Array<!Object>} */\r\n      'points': [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.smpl = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'dwManufacturer': 0,\r\n      /** @export @type {number} */\r\n      'dwProduct': 0,\r\n      /** @export @type {number} */\r\n      'dwSamplePeriod': 0,\r\n      /** @export @type {number} */\r\n      'dwMIDIUnityNote': 0,\r\n      /** @export @type {number} */\r\n      'dwMIDIPitchFraction': 0,\r\n      /** @export @type {number} */\r\n      'dwSMPTEFormat': 0,\r\n      /** @export @type {number} */\r\n      'dwSMPTEOffset': 0,\r\n      /** @export @type {number} */\r\n      'dwNumSampleLoops': 0,\r\n      /** @export @type {number} */\r\n      'dwSamplerData': 0,\r\n      /** @export @type {!Array<!Object>} */\r\n      'loops': [],\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.bext = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {string} */\r\n      'description': '', //256\r\n      /** @export @type {string} */\r\n      'originator': '', //32\r\n      /** @export @type {string} */\r\n      'originatorReference': '', //32\r\n      /** @export @type {string} */\r\n      'originationDate': '', //10\r\n      /** @export @type {string} */\r\n      'originationTime': '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @export @type {!Array<number>}\r\n       */\r\n      'timeReference': [0, 0],\r\n      /** @export @type {number} */\r\n      'version': 0, //WORD\r\n      /** @export @type {string} */\r\n      'UMID': '', // 64 chars\r\n      /** @export @type {number} */\r\n      'loudnessValue': 0, //WORD\r\n      /** @export @type {number} */\r\n      'loudnessRange': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxTruePeakLevel': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxMomentaryLoudness': 0, //WORD\r\n      /** @export @type {number} */\r\n      'maxShortTermLoudness': 0, //WORD\r\n      /** @export @type {string} */\r\n      'reserved': '', //180\r\n      /** @export @type {string} */\r\n      'codingHistory': '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {number} */\r\n      'riffSizeHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'riffSizeLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'dataSizeHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'dataSizeLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'originationTime': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'sampleCountHigh': 0, // DWORD\r\n      /** @export @type {number} */\r\n      'sampleCountLow': 0, // DWORD\r\n      /** @export @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @export @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.data = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {!Array<number>} */\r\n      'samples': []\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list must have this signature:\r\n     *  {\r\n     *    'chunkId': '',\r\n     *    'chunkSize': 0,\r\n     *    'format': '',\r\n     *    'subChunks': []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     * @export\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     * @export\r\n     */\r\n    this.junk = {\r\n      /** @export @type {string} */\r\n      'chunkId': '',\r\n      /** @export @type {number} */\r\n      'chunkSize': 0,\r\n      /** @export @type {!Array<number>} */\r\n      'chunkData': []\r\n    };\r\n    /**\r\n     * If the data in data.samples is interleaved or not.\r\n     * @type {boolean}\r\n     * @export\r\n     */\r\n    this.isInterleaved = true;\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     * @export\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here will be set to 65534\r\n     * and treated as WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @private\r\n     */\r\n    this.audioFormats_ = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.head_ = 0;\r\n    // Load a file from the buffer if one was passed\r\n    // when creating the object\r\n    if(bytes) {\r\n      this.fromBuffer(bytes);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFile object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepth The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!Array<number>} samples Array of samples to be written.\r\n   *    The samples must be in the correct range according to the\r\n   *    bit depth.\r\n   * @param {?Object} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @export\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepth, samples, options={}) {\r\n    if (!options['container']) {\r\n      options['container'] = 'RIFF';\r\n    }\r\n    this.bitDepth = bitDepth;\r\n    // interleave the samples if they were passed de-interleaved\r\n    this.data.samples = samples;\r\n    if (samples.length > 0) {\r\n      if (samples[0].constructor === Array) {\r\n        this.isInterleaved = false;\r\n        this.assureInterleaved_();\r\n      }\r\n    }\r\n    /** @type {number} */\r\n    let numBytes = (((parseInt(bitDepth, 10) - 1) | 7) + 1) / 8;\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    if (bitDepth == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    } else if (bitDepth == '8a' || bitDepth == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    } else if(Object.keys(this.audioFormats_).indexOf(bitDepth) == -1 ||\r\n        this.fmt.numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepth, numChannels, sampleRate, numBytes, options);\r\n    }\r\n    // the data chunk\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length * numBytes;\r\n    this.validateHeader_();\r\n    this.LEorBE_();\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFile object from a byte buffer.\r\n   * @param {!Uint8Array} bytes The buffer.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @export\r\n   */\r\n  fromBuffer(bytes) {\r\n    this.head_ = 0;\r\n    this.clearHeader_();\r\n    this.readRIFFChunk_(bytes);\r\n    /** @type {!Object} */\r\n    let chunk = riffIndex(bytes);\r\n    this.readDs64Chunk_(bytes, chunk['subChunks']);\r\n    this.readFmtChunk_(bytes, chunk['subChunks']);\r\n    this.readFactChunk_(bytes, chunk['subChunks']);\r\n    this.readBextChunk_(bytes, chunk['subChunks']);\r\n    this.readCueChunk_(bytes, chunk['subChunks']);\r\n    this.readSmplChunk_(bytes, chunk['subChunks']);\r\n    this.readDataChunk_(bytes, chunk['subChunks']);\r\n    this.readJunkChunk_(bytes, chunk['subChunks']);\r\n    this.readLISTChunk_(bytes, chunk['subChunks']);\r\n    this.bitDepthFromFmt_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFile object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A .wav file.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toBuffer() {\r\n    this.validateHeader_();\r\n    this.assureInterleaved_();\r\n    return this.createWaveFile_();\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a base64 string to load the WaveFile object.\r\n   * @param {string} base64String A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  fromBase64(base64String) {\r\n    this.fromBuffer(new Uint8Array(decode(base64String)));\r\n  }\r\n\r\n  /**\r\n   * Return a base64 string representig the WaveFile object as a .wav file.\r\n   * @return {string} A .wav file as a base64 string.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toBase64() {\r\n    let buffer = this.toBuffer();\r\n    return encode(buffer, 0, buffer.length);\r\n  }\r\n\r\n  /**\r\n   * Return a DataURI string representig the WaveFile object as a .wav file.\r\n   * The return of this method can be used to load the audio in browsers.\r\n   * @return {string} A .wav file as a DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  toDataURI() {\r\n    return 'data:audio/wav;base64,' + this.toBase64();\r\n  }\r\n\r\n  /**\r\n   * Use a .wav file encoded as a DataURI to load the WaveFile object.\r\n   * @param {string} dataURI A .wav file as DataURI.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @export\r\n   */\r\n  fromDataURI(dataURI) {\r\n    this.fromBase64(dataURI.replace('data:audio/wav;base64,', ''));\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   * @export\r\n   */\r\n  toRIFF() {\r\n    if (this.container == 'RF64') {\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        this.bitDepth,\r\n        this.data.samples);\r\n    } else {\r\n      this.container = 'RIFF';\r\n      this.LEorBE_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   * @export\r\n   */\r\n  toRIFX() {\r\n    if (this.container == 'RF64') {\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        this.bitDepth,\r\n        this.data.samples,\r\n        {'container': 'RIFX'});\r\n    } else {\r\n      this.container = 'RIFX';\r\n      this.LEorBE_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean} changeResolution A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   * @export\r\n   */\r\n  toBitDepth(bitDepth, changeResolution=true) {\r\n    let toBitDepth = bitDepth;\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      toBitDepth = this.realBitDepth_(bitDepth);\r\n      thisBitDepth = this.realBitDepth_(this.bitDepth);\r\n    }\r\n    this.assureInterleaved_();\r\n    this.assureUncompressed_();\r\n    this.truncateSamples();\r\n    bitdepth(this.data.samples, thisBitDepth, toBitDepth);\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      bitDepth,\r\n      this.data.samples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Interleave multi-channel samples.\r\n   * @export\r\n   */\r\n  interleave() {\r\n    if (!this.isInterleaved) {\r\n      /** @type {!Array<number>} */\r\n      let finalSamples = [];\r\n      for (let i=0; i < this.data.samples[0].length; i++) {\r\n        for (let j=0; j < this.data.samples.length; j++) {\r\n          finalSamples.push(this.data.samples[j][i]);\r\n        }\r\n      }\r\n      this.data.samples = finalSamples;\r\n      this.isInterleaved = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * De-interleave samples into multiple channels.\r\n   * @export\r\n   */\r\n  deInterleave() {\r\n    if (this.isInterleaved) {\r\n      /** @type {!Array<!Array<number>>} */\r\n      let finalSamples = [];\r\n      for (let i=0; i < this.fmt.numChannels; i++) {\r\n        finalSamples[i] = [];\r\n      }\r\n      /** @type {number} */\r\n      let len = this.data.samples.length;\r\n      for (let i=0; i < len; i+=this.fmt.numChannels) {\r\n        for (let j=0; j < this.fmt.numChannels; j++) {\r\n          finalSamples[j].push(this.data.samples[i+j]);\r\n        }\r\n      }\r\n      this.data.samples = finalSamples;\r\n      this.isInterleaved = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   * @export\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate != 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if(this.fmt.numChannels != 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      this.fromScratch(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        encodeADPCM(this.data.samples),\r\n        {'container': this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromIMAADPCM(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      decodeADPCM(this.data.samples, this.fmt.blockAlign),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit A-Law.\r\n   * @export\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    this.assureInterleaved_();\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alawmulaw.alaw.encode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromALaw(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alawmulaw.alaw.decode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   * @export\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    this.assureInterleaved_();\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      alawmulaw.mulaw.encode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string} bitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   *    Optional. Default is 16.\r\n   * @export\r\n   */\r\n  fromMuLaw(bitDepth='16') {\r\n    this.fromScratch(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alawmulaw.mulaw.decode(this.data.samples),\r\n      {'container': this.correctContainer_()});\r\n    if (bitDepth != '16') {\r\n      this.toBitDepth(bitDepth);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write a RIFF tag in the INFO chunk. If the tag do not exist,\r\n   * then it is created. It if exists, it is overwritten.\r\n   * @param {string} tag The tag name.\r\n   * @param {string} value The tag value.\r\n   * @throws {Error} If the tag name is not valid.\r\n   * @export\r\n   */\r\n  setTag(tag, value) {\r\n    tag = this.fixTagName_(tag);\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST]['subChunks'][index.TAG]['chunkSize'] =\r\n        value.length + 1;\r\n      this.LIST[index.LIST]['subChunks'][index.TAG]['value'] = value;\r\n    } else if (index.LIST !== null) {\r\n      this.LIST[index.LIST]['subChunks'].push({\r\n        'chunkId': tag,\r\n        'chunkSize': value.length + 1,\r\n        'value': value});\r\n    } else {\r\n      this.LIST.push({\r\n        'chunkId': 'LIST',\r\n        'chunkSize': 8 + value.length + 1,\r\n        'format': 'INFO',\r\n        'subChunks': []});\r\n      this.LIST[this.LIST.length - 1]['subChunks'].push({\r\n        'chunkId': tag,\r\n        'chunkSize': value.length + 1,\r\n        'value': value});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the value of a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {?string} The value if the tag is found, null otherwise.\r\n   * @export\r\n   */\r\n  getTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      return this.LIST[index.LIST]['subChunks'][index.TAG]['value'];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Remove a RIFF tag in the INFO chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {boolean} True if a tag was deleted.\r\n   * @export\r\n   */\r\n  deleteTag(tag) {\r\n    /** @type {!Object} */\r\n    let index = this.getTagIndex_(tag);\r\n    if (index.TAG !== null) {\r\n      this.LIST[index.LIST]['subChunks'].splice(index.TAG, 1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {number} position The cue point position in milliseconds.\r\n   * @param {string} labl The LIST adtl labl text of the marker. Optional.\r\n   * @export\r\n   */\r\n  setCuePoint(position, labl='') {\r\n    this.cue.chunkId = 'cue ';\r\n    position = (position * this.fmt.sampleRate) / 1000;\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n    if (len == 0) {\r\n      this.setCuePoint_(position, 1, labl);\r\n    } else {\r\n      for (let i=0; i<len; i++) {\r\n        if (existingPoints[i]['dwPosition'] > position && !hasSet) {\r\n          this.setCuePoint_(position, i + 1, labl);\r\n          this.setCuePoint_(\r\n            existingPoints[i]['dwPosition'],\r\n            i + 2,\r\n            existingPoints[i]['label']);\r\n          hasSet = true;\r\n        } else {\r\n          this.setCuePoint_(\r\n            existingPoints[i]['dwPosition'],\r\n            i + 1,\r\n            existingPoints[i]['label']);\r\n        }\r\n      }\r\n      if (!hasSet) {\r\n        this.setCuePoint_(position, this.cue.points.length + 1, labl);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   * @export\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i=0; i<len; i++) {\r\n      if (i + 1 != index) {\r\n        this.setCuePoint_(\r\n          existingPoints[i]['dwPosition'],\r\n          i + 1,\r\n          existingPoints[i]['label']);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   * @export\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex !== null) {\r\n      for (let i=0; i<this.LIST[adtlIndex]['subChunks'].length; i++) {\r\n        if (this.LIST[adtlIndex]['subChunks'][i]['dwName'] ==\r\n            pointIndex) {\r\n          this.LIST[adtlIndex]['subChunks'][i]['value'] = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {number} position The position in milliseconds.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(position, dwName, label) {\r\n    this.cue.points.push({\r\n      'dwName': dwName,\r\n      'dwPosition': position,\r\n      'fccChunk': 'data',\r\n      'dwChunkStart': 0,\r\n      'dwBlockStart': 0,\r\n      'dwSampleOffset': position,\r\n    });\r\n    this.setLabl_(dwName, label);\r\n  }\r\n\r\n  /**\r\n   * Return an array with the position of all cue points in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.points.length; i++) {\r\n      points.push({\r\n        'dwPosition': this.cue.points[i]['dwPosition'],\r\n        'label': this.getLabelForCuePoint_(\r\n          this.cue.points[i]['dwName'])});\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the label of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  getLabelForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex !== null) {\r\n      for (let i=0; i<this.LIST[adtlIndex]['subChunks'].length; i++) {\r\n        if (this.LIST[adtlIndex]['subChunks'][i]['dwName'] ==\r\n            pointDwName) {\r\n          return this.LIST[adtlIndex]['subChunks'][i]['value'];\r\n        }\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if (this.LIST[i]['format'] == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @param {string} label The label for the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(dwName, label) {\r\n    /** @type {?number} */\r\n    let adtlIndex = this.getAdtlChunk_();\r\n    if (adtlIndex === null) {\r\n      this.LIST.push({\r\n        'chunkId': 'LIST',\r\n        'chunkSize': 4,\r\n        'format': 'adtl',\r\n        'subChunks': []});\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex === null ? 0 : adtlIndex, dwName, label);\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @param {string} label The label for the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, dwName, label) {\r\n    this.LIST[adtlIndex]['subChunks'].push({\r\n      'chunkId': 'labl',\r\n      'chunkSize': label.length,\r\n      'dwName': dwName,\r\n      'value': label\r\n    });\r\n    this.LIST[adtlIndex]['chunkSize'] += label.length + 4 + 4 + 4 + 1;\r\n  }\r\n\r\n  /**\r\n   * Return the index of the 'adtl' LIST in this.LIST.\r\n   * @return {?number}\r\n   * @private\r\n   */\r\n  getAdtlChunk_() {\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if(this.LIST[i]['format'] == 'adtl') {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Return the index of a tag in a FILE chunk.\r\n   * @param {string} tag The tag name.\r\n   * @return {!Object<string, ?number>}\r\n   *    Object.LIST is the INFO index in LIST\r\n   *    Object.TAG is the tag index in the INFO\r\n   * @private\r\n   */\r\n  getTagIndex_(tag) {\r\n    /** @type {!Object<string, ?number>} */\r\n    let index = {LIST: null, TAG: null};\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      if (this.LIST[i]['format'] == 'INFO') {\r\n        index.LIST = i;\r\n        for (let j=0; j<this.LIST[i]['subChunks'].length; j++) {\r\n          if (this.LIST[i]['subChunks'][j]['chunkId'] == tag) {\r\n            index.TAG = j;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Fix a RIFF tag format if possible, throw an error otherwise.\r\n   * @param {string} tag The tag name.\r\n   * @return {string} The tag name in proper fourCC format.\r\n   * @private\r\n   */\r\n  fixTagName_(tag) {\r\n    if (tag.constructor !== String) {\r\n      throw new Error('Invalid tag name.');\r\n    } else if(tag.length < 4) {\r\n      for (let i=0; i<4-tag.length; i++) {\r\n        tag += ' ';\r\n      }\r\n    }\r\n    return tag;\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 40 + this.data.samples.length;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact.chunkId = 'fact';\r\n    this.fact.chunkSize = 4;\r\n    this.fact.dwSampleLength = this.data.samples.length * 2;\r\n    this.data.chunkSize = this.data.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 36 + 24 + this.data.samples.length * numBytes;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepth, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepth, 10);\r\n    this.fmt.dwChannelMask = this.getDwChannelMask_();\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Get the value for dwChannelMask according to the number of channels.\r\n   * @return {number} the dwChannelMask value.\r\n   * @private\r\n   */\r\n  getDwChannelMask_() {\r\n    /** @type {number} */\r\n    let dwChannelMask = 0;\r\n    // mono = FC\r\n    if (this.fmt.numChannels == 1) {\r\n      dwChannelMask = 0x4;\r\n    // stereo = FL, FR\r\n    } else if (this.fmt.numChannels == 2) {\r\n      dwChannelMask = 0x3;\r\n    // quad = FL, FR, BL, BR\r\n    } else if (this.fmt.numChannels == 4) {\r\n      dwChannelMask = 0x33;\r\n    // 5.1 = FL, FR, FC, LF, BL, BR\r\n    } else if (this.fmt.numChannels == 6) {\r\n      dwChannelMask = 0x3F;\r\n    // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n    } else if (this.fmt.numChannels == 8) {\r\n      dwChannelMask = 0x63F;\r\n    }\r\n    return dwChannelMask;\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.createPCMHeader_(\r\n      bitDepth, numChannels, sampleRate, numBytes, options);\r\n    this.chunkSize = 40 + this.data.samples.length;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact.chunkId = 'fact';\r\n    this.fact.chunkSize = 4;\r\n    this.fact.dwSampleLength = this.data.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepth The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(bitDepth, numChannels, sampleRate, numBytes, options) {\r\n    this.clearHeader_();\r\n    this.container = options['container'];\r\n    this.chunkSize = 36 + this.data.samples.length * numBytes;\r\n    this.format = 'WAVE';\r\n    this.fmt.chunkId = 'fmt ';\r\n    this.fmt.chunkSize = 16;\r\n    this.fmt.byteRate = (numChannels * numBytes) * sampleRate;\r\n    this.fmt.blockAlign = numChannels * numBytes;\r\n    this.fmt.audioFormat = this.audioFormats_[bitDepth] ?\r\n      this.audioFormats_[bitDepth] : 65534;\r\n    this.fmt.numChannels = numChannels;\r\n    this.fmt.sampleRate = sampleRate;\r\n    this.fmt.bitsPerSample = parseInt(bitDepth, 10);\r\n    this.fmt.cbSize = 0;\r\n    this.fmt.validBitsPerSample = 0;\r\n  }\r\n\r\n  /**\r\n   * Return the closest greater number of bits for a number of bits that\r\n   * do not fill a full sequence of bytes.\r\n   * @param {string} bitDepth The bit depth.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  realBitDepth_(bitDepth) {\r\n    if (bitDepth != '32f') {\r\n      bitDepth = (((parseInt(bitDepth, 10) - 1) | 7) + 1).toString();\r\n    }\r\n    return bitDepth;\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If any property of the object appears invalid.\r\n   * @private\r\n   */\r\n  validateHeader_() {\r\n    this.validateBitDepth_();\r\n    this.validateNumChannels_();\r\n    this.validateSampleRate_();\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.audioFormats_[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate the number of channels.\r\n   * @return {boolean} True is the number of channels is valid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @private\r\n   */\r\n  validateNumChannels_() {\r\n    /** @type {number} */\r\n    let blockAlign = this.fmt.numChannels * this.fmt.bitsPerSample / 8;\r\n    if (this.fmt.numChannels < 1 || blockAlign > 65535) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate the sample rate value.\r\n   * @return {boolean} True is the sample rate is valid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @private\r\n   */\r\n  validateSampleRate_() {\r\n    /** @type {number} */\r\n    let byteRate = this.fmt.numChannels *\r\n      (this.fmt.bitsPerSample / 8) * this.fmt.sampleRate;\r\n    if (this.fmt.sampleRate < 1 || byteRate > 4294967295) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Reset attributes that should emptied when a file is\r\n   * created with the fromScratch() or fromBuffer() methods.\r\n   * @private\r\n   */\r\n  clearHeader_() {\r\n    this.fmt.cbSize = 0;\r\n    this.fmt.validBitsPerSample = 0;\r\n    this.fact.chunkId = '';\r\n    this.ds64.chunkId = '';\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if(this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Interleave the samples in case they are de-Interleaved.\r\n   * @private\r\n   */\r\n  assureInterleaved_() {\r\n    if (!this.isInterleaved) {\r\n      this.interleave();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set up to work wih big-endian or little-endian files.\r\n   * The types used are changed to LE or BE. If the\r\n   * the file is big-endian (RIFX), true is returned.\r\n   * @return {boolean} True if the file is RIFX.\r\n   * @private\r\n   */\r\n  LEorBE_() {\r\n    /** @type {boolean} */\r\n    let bigEndian = this.container === 'RIFX';\r\n    uInt16_['be'] = bigEndian;\r\n    uInt32_['be'] = bigEndian;\r\n    return bigEndian;\r\n  }\r\n\r\n  /**\r\n   * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n   * @param {!Object} chunks The wav file chunks.\r\n   * @param {string} chunkId The chunk fourCC_.\r\n   * @param {boolean} multiple True if there may be multiple chunks\r\n   *    with the same chunkId.\r\n   * @return {Object|Array<!Object>|null}\r\n   * @private\r\n   */\r\n  findChunk_(chunks, chunkId, multiple=false) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i]['chunkId'] == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read the RIFF chunk a wave file.\r\n   * @param {!Uint8Array} bytes A wav buffer.\r\n   * @throws {Error} If no 'RIFF' chunk is found.\r\n   * @private\r\n   */\r\n  readRIFFChunk_(bytes) {\r\n    this.head_ = 0;\r\n    this.container = this.readString_(bytes, 4);\r\n    if (['RIFF', 'RIFX', 'RF64'].indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.LEorBE_();\r\n    this.chunkSize = this.read_(bytes, uInt32_);\r\n    this.format = this.readString_(bytes, 4);\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'fmt ');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.fmt.chunkId = chunk['chunkId'];\r\n      this.fmt.chunkSize = chunk['chunkSize'];\r\n      this.fmt.audioFormat = this.read_(buffer, uInt16_);\r\n      this.fmt.numChannels = this.read_(buffer, uInt16_);\r\n      this.fmt.sampleRate = this.read_(buffer, uInt32_);\r\n      this.fmt.byteRate = this.read_(buffer, uInt32_);\r\n      this.fmt.blockAlign = this.read_(buffer, uInt16_);\r\n      this.fmt.bitsPerSample = this.read_(buffer, uInt16_);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.read_(buffer, uInt16_);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.read_(buffer, uInt16_);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.read_(buffer, uInt32_);\r\n          this.fmt.subformat = [\r\n            this.read_(buffer, uInt32_),\r\n            this.read_(buffer, uInt32_),\r\n            this.read_(buffer, uInt32_),\r\n            this.read_(buffer, uInt32_)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'fact');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.fact.chunkId = chunk['chunkId'];\r\n      this.fact.chunkSize = chunk['chunkSize'];\r\n      this.fact.dwSampleLength = this.read_(buffer, uInt32_);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'cue ');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.cue.chunkId = chunk['chunkId'];\r\n      this.cue.chunkSize = chunk['chunkSize'];\r\n      this.cue.dwCuePoints = this.read_(buffer, uInt32_);\r\n      for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          'dwName': this.read_(buffer, uInt32_),\r\n          'dwPosition': this.read_(buffer, uInt32_),\r\n          'fccChunk': this.readString_(buffer, 4),\r\n          'dwChunkStart': this.read_(buffer, uInt32_),\r\n          'dwBlockStart': this.read_(buffer, uInt32_),\r\n          'dwSampleOffset': this.read_(buffer, uInt32_),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'smpl');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.smpl.chunkId = chunk['chunkId'];\r\n      this.smpl.chunkSize = chunk['chunkSize'];\r\n      this.smpl.dwManufacturer = this.read_(buffer, uInt32_);\r\n      this.smpl.dwProduct = this.read_(buffer, uInt32_);\r\n      this.smpl.dwSamplePeriod = this.read_(buffer, uInt32_);\r\n      this.smpl.dwMIDIUnityNote = this.read_(buffer, uInt32_);\r\n      this.smpl.dwMIDIPitchFraction = this.read_(buffer, uInt32_);\r\n      this.smpl.dwSMPTEFormat = this.read_(buffer, uInt32_);\r\n      this.smpl.dwSMPTEOffset = this.read_(buffer, uInt32_);\r\n      this.smpl.dwNumSampleLoops = this.read_(buffer, uInt32_);\r\n      this.smpl.dwSamplerData = this.read_(buffer, uInt32_);\r\n      for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          'dwName': this.read_(buffer, uInt32_),\r\n          'dwType': this.read_(buffer, uInt32_),\r\n          'dwStart': this.read_(buffer, uInt32_),\r\n          'dwEnd': this.read_(buffer, uInt32_),\r\n          'dwFraction': this.read_(buffer, uInt32_),\r\n          'dwPlayCount': this.read_(buffer, uInt32_),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk['chunkSize'];\r\n      this.samplesFromBytes_(buffer, chunk);\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'bext');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.bext.chunkId = chunk['chunkId'];\r\n      this.bext.chunkSize = chunk['chunkSize'];\r\n      this.bext.description = this.readString_(buffer, 256);\r\n      this.bext.originator = this.readString_(buffer, 32);\r\n      this.bext.originatorReference = this.readString_(buffer, 32);\r\n      this.bext.originationDate = this.readString_(buffer, 10);\r\n      this.bext.originationTime = this.readString_(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.read_(buffer, uInt32_),\r\n        this.read_(buffer, uInt32_)];\r\n      this.bext.version = this.read_(buffer, uInt16_);\r\n      this.bext.UMID = this.readString_(buffer, 64);\r\n      this.bext.loudnessValue = this.read_(buffer, uInt16_);\r\n      this.bext.loudnessRange = this.read_(buffer, uInt16_);\r\n      this.bext.maxTruePeakLevel = this.read_(buffer, uInt16_);\r\n      this.bext.maxMomentaryLoudness = this.read_(buffer, uInt16_);\r\n      this.bext.maxShortTermLoudness = this.read_(buffer, uInt16_);\r\n      this.bext.reserved = this.readString_(buffer, 180);\r\n      this.bext.codingHistory = this.readString_(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'ds64');\r\n    if (chunk) {\r\n      this.head_ = chunk['chunkData']['start'];\r\n      this.ds64.chunkId = chunk['chunkId'];\r\n      this.ds64.chunkSize = chunk['chunkSize'];\r\n      this.ds64.riffSizeHigh = this.read_(buffer, uInt32_);\r\n      this.ds64.riffSizeLow = this.read_(buffer, uInt32_);\r\n      this.ds64.dataSizeHigh = this.read_(buffer, uInt32_);\r\n      this.ds64.dataSizeLow = this.read_(buffer, uInt32_);\r\n      this.ds64.originationTime = this.read_(buffer, uInt32_);\r\n      this.ds64.sampleCountHigh = this.read_(buffer, uInt32_);\r\n      this.ds64.sampleCountLow = this.read_(buffer, uInt32_);\r\n      //if (this.ds64.chunkSize > 28) {\r\n      //  this.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  this.ds64.table = chunkData.slice(\r\n      //     32, 32 + this.ds64.tableLength); \r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');  \r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk_(signature, 'LIST', true);\r\n    if (listChunks === null) {\r\n      return;\r\n    }\r\n    for (let j=0; j < listChunks.length; j++) {\r\n      /** @type {!Object} */\r\n      let subChunk = listChunks[j];\r\n      this.LIST.push({\r\n        'chunkId': subChunk['chunkId'],\r\n        'chunkSize': subChunk['chunkSize'],\r\n        'format': subChunk['format'],\r\n        'subChunks': []});\r\n      for (let x=0; x<subChunk['subChunks'].length; x++) {\r\n        this.readLISTSubChunks_(subChunk['subChunks'][x],\r\n          subChunk['format'], buffer);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk['chunkId']) > -1) {\r\n        this.head_ = subChunk['chunkData']['start'];\r\n        /** @type {!Object<string, string|number>} */\r\n        let item = {\r\n          'chunkId': subChunk['chunkId'],\r\n          'chunkSize': subChunk['chunkSize'],\r\n          'dwName': this.read_(buffer, uInt32_)\r\n        };\r\n        if (subChunk['chunkId'] == 'ltxt') {\r\n          item['dwSampleLength'] = this.read_(buffer, uInt32_);\r\n          item['dwPurposeID'] = this.read_(buffer, uInt32_);\r\n          item['dwCountry'] = this.read_(buffer, uInt16_);\r\n          item['dwLanguage'] = this.read_(buffer, uInt16_);\r\n          item['dwDialect'] = this.read_(buffer, uInt16_);\r\n          item['dwCodePage'] = this.read_(buffer, uInt16_);\r\n        }\r\n        item['value'] = this.readZSTR_(buffer, this.head_);\r\n        this.LIST[this.LIST.length - 1]['subChunks'].push(item);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.head_ = subChunk['chunkData']['start'];\r\n      this.LIST[this.LIST.length - 1]['subChunks'].push({\r\n        'chunkId': subChunk['chunkId'],\r\n        'chunkSize': subChunk['chunkSize'],\r\n        'value': this.readZSTR_(buffer,  this.head_)\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} signature The file signature.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer, signature) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk_(signature, 'junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        'chunkId': chunk['chunkId'],\r\n        'chunkSize': chunk['chunkSize'],\r\n        'chunkData': [].slice.call(buffer.slice(\r\n          chunk['chunkData']['start'],\r\n          chunk['chunkData']['end']))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Array<number>|!Uint8Array} bytes The bytes.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    for (let i=index; i<bytes.length; i++) {\r\n      this.head_++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n      str += unpackFrom(bytes, types.chr, i);\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Array<number>|!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readString_(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    for (let i=0; i<maxSize; i++) {\r\n      str += unpackFrom(bytes, types.chr, this.head_);\r\n      this.head_++;\r\n    }\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Array<number>|!Uint8Array} bytes The chunk bytes.\r\n   * @param {!Object} bdType The type definition.\r\n   * @return {number|string} The number.\r\n   * @private\r\n   */\r\n  read_(bytes, bdType) {\r\n    /** @type {number} */\r\n    let size = bdType['bits'] / 8;\r\n    /** @type {number|string} */\r\n    let value = unpackFrom(bytes, bdType, this.head_);\r\n    this.head_ += size;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Write a variable size string as bytes. If the string is smaller\r\n   * than the max size the output array is filled with 0s.\r\n   * @param {string} str The string to be written as bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {!Array<number>} The bytes.\r\n   * @private\r\n   */\r\n  writeString_(str, maxSize, push=true) {\r\n    /** @type {!Array<number>} */   \r\n    let bytes = packArray(str, types.chr);\r\n    if (push) {\r\n      for (let i=bytes.length; i<maxSize; i++) {\r\n        bytes.push(0);\r\n      }  \r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Turn the samples to bytes.\r\n   * @return {!Array<number>} The bytes.\r\n   * @private\r\n   */\r\n  samplesToBytes_() {\r\n    return packArray(\r\n      this.data.samples, this.getSamplesType_());\r\n  }\r\n\r\n  /**\r\n   * Truncate float samples on over and underflow.\r\n   * @private\r\n   */\r\n  truncateSamples() {\r\n    if (this.fmt.audioFormat == 3) {\r\n      /** @type {number} */   \r\n      let len = this.data.samples.length;\r\n      for (let i=0; i<len; i++) {\r\n        if (this.data.samples[i] > 1) {\r\n          this.data.samples[i] = 1;\r\n        } else if (this.data.samples[i] < -1) {\r\n          this.data.samples[i] = -1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Turn bytes to samples and load them in the data.samples property.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @private\r\n   */\r\n  samplesFromBytes_(bytes, chunkData) {\r\n    this.data.samples = unpackArrayFrom(\r\n      bytes,\r\n      this.getSamplesType_(),\r\n      chunkData['chunkData']['start'],\r\n      chunkData['chunkData']['end']);\r\n  }\r\n\r\n  /**\r\n   * Get the data type definition for the samples.\r\n   * @return {!Object<string, number|boolean>} The type definition.\r\n   * @private\r\n   */\r\n  getSamplesType_() {\r\n    /** @type {!Object<string, number|boolean>} */\r\n    let bdType = {\r\n      'be': this.container === 'RIFX',\r\n      'bits': this.fmt.bitsPerSample == 4 ? 8 : this.fmt.bitsPerSample,\r\n      'float': this.fmt.audioFormat == 3 ? true : false\r\n    };\r\n    bdType['signed'] = bdType['bits'] == 8 ? false : true;\r\n    return bdType;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @return {!Array<number>} The 'bext' chunk bytes.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.bext.chunkId, types.fourCC),\r\n        pack(602 + this.bext.codingHistory.length, uInt32_),\r\n        this.writeString_(this.bext.description, 256),\r\n        this.writeString_(this.bext.originator, 32),\r\n        this.writeString_(this.bext.originatorReference, 32),\r\n        this.writeString_(this.bext.originationDate, 10),\r\n        this.writeString_(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], uInt32_),\r\n        pack(this.bext.timeReference[1], uInt32_),\r\n        pack(this.bext.version, uInt16_),\r\n        this.writeString_(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, uInt16_),\r\n        pack(this.bext.loudnessRange, uInt16_),\r\n        pack(this.bext.maxTruePeakLevel, uInt16_),\r\n        pack(this.bext.maxMomentaryLoudness, uInt16_),\r\n        pack(this.bext.maxShortTermLoudness, uInt16_),\r\n        this.writeString_(this.bext.reserved, 180),\r\n        this.writeString_(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (var prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.ds64.chunkId, types.fourCC),\r\n        pack(this.ds64.chunkSize, uInt32_),\r\n        pack(this.ds64.riffSizeHigh, uInt32_),\r\n        pack(this.ds64.riffSizeLow, uInt32_),\r\n        pack(this.ds64.dataSizeHigh, uInt32_),\r\n        pack(this.ds64.dataSizeLow, uInt32_),\r\n        pack(this.ds64.originationTime, uInt32_),\r\n        pack(this.ds64.sampleCountHigh, uInt32_),\r\n        pack(this.ds64.sampleCountLow, uInt32_));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, uInt32_),\r\n    //    this.ds64.table);\r\n    //}\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        pack(this.cue.chunkId, types.fourCC),\r\n        pack(cuePointsBytes.length + 4, uInt32_),\r\n        pack(this.cue.dwCuePoints, uInt32_),\r\n        cuePointsBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i]['dwName'], uInt32_),\r\n        pack(this.cue.points[i]['dwPosition'], uInt32_),\r\n        pack(this.cue.points[i]['fccChunk'], types.fourCC),\r\n        pack(this.cue.points[i]['dwChunkStart'], uInt32_),\r\n        pack(this.cue.points[i]['dwBlockStart'], uInt32_),\r\n        pack(this.cue.points[i]['dwSampleOffset'], uInt32_));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        pack(this.smpl.chunkId, types.fourCC),\r\n        pack(smplLoopsBytes.length + 36, uInt32_),\r\n        pack(this.smpl.dwManufacturer, uInt32_),\r\n        pack(this.smpl.dwProduct, uInt32_),\r\n        pack(this.smpl.dwSamplePeriod, uInt32_),\r\n        pack(this.smpl.dwMIDIUnityNote, uInt32_),\r\n        pack(this.smpl.dwMIDIPitchFraction, uInt32_),\r\n        pack(this.smpl.dwSMPTEFormat, uInt32_),\r\n        pack(this.smpl.dwSMPTEOffset, uInt32_),\r\n        pack(this.smpl.dwNumSampleLoops, uInt32_),\r\n        pack(this.smpl.dwSamplerData, uInt32_),\r\n        smplLoopsBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i]['dwName'], uInt32_),\r\n        pack(this.smpl.loops[i]['dwType'], uInt32_),\r\n        pack(this.smpl.loops[i]['dwStart'], uInt32_),\r\n        pack(this.smpl.loops[i]['dwEnd'], uInt32_),\r\n        pack(this.smpl.loops[i]['dwFraction'], uInt32_),\r\n        pack(this.smpl.loops[i]['dwPlayCount'], uInt32_));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        pack(this.fact.chunkId, types.fourCC),\r\n        pack(this.fact.chunkSize, uInt32_),\r\n        pack(this.fact.dwSampleLength, uInt32_));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    if (this.fmt.chunkId) {\r\n      return [].concat(\r\n        pack(this.fmt.chunkId, types.fourCC),\r\n        pack(this.fmt.chunkSize, uInt32_),\r\n        pack(this.fmt.audioFormat, uInt16_),\r\n        pack(this.fmt.numChannels, uInt16_),\r\n        pack(this.fmt.sampleRate, uInt32_),\r\n        pack(this.fmt.byteRate, uInt32_),\r\n        pack(this.fmt.blockAlign, uInt16_),\r\n        pack(this.fmt.bitsPerSample, uInt16_),\r\n        this.getFmtExtensionBytes_());\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, uInt16_));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, uInt16_));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, uInt32_));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], uInt32_),\r\n        pack(this.fmt.subformat[1], uInt32_),\r\n        pack(this.fmt.subformat[2], uInt32_),\r\n        pack(this.fmt.subformat[3], uInt32_));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @export for tests\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i]['subChunks'], this.LIST[i]['format']);\r\n      bytes = bytes.concat(\r\n        pack(this.LIST[i]['chunkId'], types.fourCC),\r\n        pack(subChunksBytes.length + 4, uInt32_),\r\n        pack(this.LIST[i]['format'], types.fourCC),\r\n        subChunksBytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<subChunks.length; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(\r\n          pack(subChunks[i]['chunkId'], types.fourCC),\r\n          pack(subChunks[i]['value'].length + 1, uInt32_),\r\n          this.writeString_(\r\n            subChunks[i]['value'], subChunks[i]['value'].length));\r\n        bytes.push(0);\r\n      } else if (format == 'adtl') {\r\n        if (['labl', 'note'].indexOf(subChunks[i]['chunkId']) > -1) {\r\n          bytes = bytes.concat(\r\n            pack(subChunks[i]['chunkId'], types.fourCC),\r\n            pack(\r\n              subChunks[i]['value'].length + 4 + 1, uInt32_),\r\n            pack(subChunks[i]['dwName'], uInt32_),\r\n            this.writeString_(\r\n              subChunks[i]['value'],\r\n              subChunks[i]['value'].length));\r\n          bytes.push(0);\r\n        } else if (subChunks[i]['chunkId'] == 'ltxt') {\r\n          bytes = bytes.concat(\r\n            this.getLtxtChunkBytes_(subChunks[i]));\r\n        }\r\n      }\r\n      if (bytes.length % 2) {\r\n        bytes.push(0);\r\n      }\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>} The 'ltxt' chunk bytes.\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      pack(ltxt['chunkId'], types.fourCC),\r\n      pack(ltxt['value'].length + 20, uInt32_),\r\n      pack(ltxt['dwName'], uInt32_),\r\n      pack(ltxt['dwSampleLength'], uInt32_),\r\n      pack(ltxt['dwPurposeID'], uInt32_),\r\n      pack(ltxt['dwCountry'], uInt16_),\r\n      pack(ltxt['dwLanguage'], uInt16_),\r\n      pack(ltxt['dwLanguage'], uInt16_),\r\n      pack(ltxt['dwCodePage'], uInt16_),\r\n      this.writeString_(ltxt['value'], ltxt['value'].length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @return {!Array<number>} The 'junk' chunk bytes.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        pack(this.junk.chunkId, types.fourCC),\r\n        pack(this.junk.chunkData.length, uInt32_),\r\n        this.junk.chunkData);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat == 3 && this.fmt.bitsPerSample == 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat == 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat == 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a .wav file byte buffer with the data from the WaveFile object.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} The wav file bytes.\r\n   * @private\r\n   */\r\n  createWaveFile_() {\r\n    /** @type {!Array<number>} */\r\n    let samplesBytes = this.samplesToBytes_();\r\n    /** @type {!Array<number>} */\r\n    let fileBody = [].concat(\r\n      pack(this.format, types.fourCC),\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      pack(this.data.chunkId, types.fourCC),\r\n      pack(samplesBytes.length, uInt32_),\r\n      samplesBytes,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_());\r\n    return new Uint8Array([].concat(\r\n      pack(this.container, types.fourCC),\r\n      pack(fileBody.length, uInt32_),\r\n      fileBody));      \r\n  }\r\n}\r\n","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2017 Brett Zamir, 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n// Use a lookup table to find the index.\nconst lookup = new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\n\nexport const encode = function (arraybuffer, byteOffset, length) {\n    const bytes = new Uint8Array(arraybuffer, byteOffset, length),\n        len = bytes.length;\n    let base64 = '';\n\n    for (let i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n\n    return base64;\n};\n\nexport const decode = function (base64) {\n    const len = base64.length;\n\n    let bufferLength = base64.length * 0.75;\n    let p = 0;\n    let encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    const arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (let i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n};\n","/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Pack and unpack two's complement ints and unsigned ints.\r\n */\r\n\r\n/**\r\n * @module byteData/integer\r\n * @ignore\r\n */\r\n\r\n/**\r\n * A class to pack and unpack two's complement ints and unsigned ints.\r\n * \r\n */\r\nexport default class Integer {\r\n\r\n  /**\r\n   * @param {number} bits Number of bits used by the data.\r\n   * @param {boolean} signed True for signed types.\r\n   * @throws {Error} if the number of bits is smaller than 1 or greater than 64.\r\n   */\r\n  constructor(bits, signed) {\r\n    /**\r\n     * The max number of bits used by the data.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * If this type it is signed or not.\r\n     * @type {boolean}\r\n     */\r\n    this.signed = signed;\r\n    /**\r\n     * The number of bytes used by the data.\r\n     * @type {number}\r\n     */\r\n    this.offset = 0;\r\n    /**\r\n     * Min value for numbers of this type.\r\n     * @type {number}\r\n     */\r\n    this.min = -Infinity;\r\n    /**\r\n     * Max value for numbers of this type.\r\n     * @type {number}\r\n     */\r\n    this.max = Infinity;\r\n    /**\r\n     * The practical number of bits used by the data.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.realBits_ = this.bits;\r\n    /**\r\n     * The mask to be used in the last byte.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.lastByteMask_ = 255;\r\n    this.build_();\r\n  }\r\n\r\n  /**\r\n   * Read one integer number from a byte buffer.\r\n   * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n   * @param {number=} i The index to read.\r\n   * @return {number}\r\n   */\r\n  read(bytes, i=0) {\r\n    let num = 0;\r\n    let x = this.offset - 1;\r\n    while (x > 0) {\r\n      num = (bytes[x + i] << x * 8) | num;\r\n      x--;\r\n    }\r\n    num = (bytes[i] | num) >>> 0;\r\n    return this.overflow_(this.sign_(num));\r\n  }\r\n\r\n  /**\r\n   * Write one integer number to a byte buffer.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number=} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  write(bytes, number, j=0) {\r\n    number = this.overflow_(number);\r\n    bytes[j++] = number & 255;\r\n    for (let i = 2; i <= this.offset; i++) {\r\n      bytes[j++] = Math.floor(number / Math.pow(2, ((i - 1) * 8))) & 255;\r\n    }\r\n    return j;\r\n  }\r\n\r\n  /**\r\n   * Write one integer number to a byte buffer.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number=} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   * @private\r\n   */\r\n  writeEsoteric_(bytes, number, j=0) {\r\n    number = this.overflow_(number);\r\n    j = this.writeFirstByte_(bytes, number, j);\r\n    for (let i = 2; i < this.offset; i++) {\r\n      bytes[j++] = Math.floor(number / Math.pow(2, ((i - 1) * 8))) & 255;\r\n    }\r\n    if (this.bits > 8) {\r\n      bytes[j++] = Math.floor(\r\n          number / Math.pow(2, ((this.offset - 1) * 8))) &\r\n        this.lastByteMask_;\r\n    }\r\n    return j;\r\n  }\r\n\r\n  /**\r\n   * Read a integer number from a byte buffer by turning int bytes\r\n   * to a string of bits. Used for data with more than 32 bits.\r\n   * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n   * @param {number=} i The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  readBits_(bytes, i=0) {\r\n    let binary = '';\r\n    let j = 0;\r\n    while(j < this.offset) {\r\n      let bits = bytes[i + j].toString(2);\r\n      binary = new Array(9 - bits.length).join('0') + bits + binary;\r\n      j++;\r\n    }\r\n    return this.overflow_(this.sign_(parseInt(binary, 2)));\r\n  }\r\n\r\n  /**\r\n   * Build the type.\r\n   * @throws {Error} if the number of bits is smaller than 1 or greater than 64.\r\n   * @private\r\n   */\r\n  build_() {\r\n    this.setRealBits_();\r\n    this.setLastByteMask_();\r\n    this.setMinMax_();\r\n    this.offset = this.bits < 8 ? 1 : Math.ceil(this.realBits_ / 8);\r\n    if ((this.realBits_ != this.bits) || this.bits < 8 || this.bits > 32) {\r\n      this.write = this.writeEsoteric_;\r\n      this.read = this.readBits_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Limit the value according to the bit depth in case of\r\n   * overflow or underflow.\r\n   * @param {number} value The data.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  overflow_(value) {\r\n    if (value > this.max) {\r\n      throw new Error('Overflow.');\r\n    } else if (value < this.min) {\r\n      throw new Error('Underflow.');\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Set the minimum and maximum values for the type.\r\n   * @private\r\n   */\r\n  setMinMax_() {\r\n    let max = Math.pow(2, this.bits);\r\n    if (this.signed) {\r\n      this.max = max / 2 -1;\r\n      this.min = -max / 2;\r\n    } else {\r\n      this.max = max - 1;\r\n      this.min = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the practical bit number for data with bit count different\r\n   * from the standard types (8, 16, 32, 40, 48, 64) and more than 8 bits.\r\n   * @private\r\n   */\r\n  setRealBits_() {\r\n    if (this.bits > 8) {\r\n      this.realBits_ = ((this.bits - 1) | 7) + 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the mask that should be used when writing the last byte.\r\n   * @private\r\n   */\r\n  setLastByteMask_() {\r\n    let r = 8 - (this.realBits_ - this.bits);\r\n    this.lastByteMask_ = Math.pow(2, r > 0 ? r : 8) -1;\r\n  }\r\n\r\n  /**\r\n   * Write the first byte of a integer number.\r\n   * @param {!Array<number>} bytes An array of bytes.\r\n   * @param {number} number The number.\r\n   * @param {number} j The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   * @private\r\n   */\r\n  writeFirstByte_(bytes, number, j) {\r\n    if (this.bits < 8) {\r\n      bytes[j++] = number < 0 ? number + Math.pow(2, this.bits) : number;\r\n    } else {\r\n      bytes[j++] = number & 255;\r\n    }\r\n    return j;\r\n  }\r\n}\r\n","/*\r\n * bitdepth: Change the resolution of samples to and from any bit depth.\r\n * https://github.com/rochars/bitdepth\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The bitdepth() function and private helper functions.\r\n */\r\n\r\n/** @module bitdepth */\r\n\r\n/** @private */\r\nconst f64f32_ = new Float32Array(1);\r\n\r\n/**\r\n * Change the bit depth of samples. The input array is modified in-place.\r\n * @param {!Array<number>} samples The samples.\r\n * @param {string} original The original bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {string} target The desired bit depth for the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {Array<number>=} outputArray An optional array to write\r\n        converted samples to. Useful for writing to typed arrays.\r\n */\r\nexport default function bitdepth(samples, original, target, outputArray) {\r\n  validateBitDepth_(original);\r\n  validateBitDepth_(target);\r\n  outputArray = outputArray || samples;\r\n  /** @type {!Function} */\r\n  let toFunction = getBitDepthFunction_(original, target);\r\n  /** @type {!Object<string, number>} */\r\n  let options = {\r\n    oldMin: Math.pow(2, parseInt(original, 10)) / 2,\r\n    newMin: Math.pow(2, parseInt(target, 10)) / 2,\r\n    oldMax: (Math.pow(2, parseInt(original, 10)) / 2) - 1,\r\n    newMax: (Math.pow(2, parseInt(target, 10)) / 2) - 1,\r\n  };\r\n  /** @type {number} */\r\n  const len = samples.length;\r\n  // sign the samples if original is 8-bit\r\n  if (original == \"8\") {\r\n    for (let i=0; i<len; i++) {\r\n      outputArray[i] = samples[i] -= 128;\r\n    }\r\n  }\r\n  // change the resolution of the samples\r\n  for (let i=0; i<len; i++) {        \r\n    outputArray[i] = toFunction(samples[i], options);\r\n  }\r\n  // unsign the samples if target is 8-bit\r\n  if (target == \"8\") {\r\n    for (let i=0; i<len; i++) {\r\n      outputArray[i] = outputArray[i] += 128;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToInt_(sample, args) {\r\n  if (sample > 0) {\r\n    sample = parseInt((sample / args.oldMax) * args.newMax, 10);\r\n  } else {\r\n    sample = parseInt((sample / args.oldMin) * args.newMin, 10);\r\n  }\r\n  return sample;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to int.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToInt_(sample, args) {\r\n  return parseInt(\r\n    sample > 0 ? sample * args.newMax : sample * args.newMin, 10);\r\n}\r\n\r\n/**\r\n * Change the bit depth from int to float.\r\n * @param {number} sample The sample.\r\n * @param {!Object<string, number>} args Data about the original and target bit depths.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction intToFloat_(sample, args) {\r\n  return sample > 0 ? sample / args.oldMax : sample / args.oldMin;\r\n}\r\n\r\n/**\r\n * Change the bit depth from float to float.\r\n * @param {number} sample The sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction floatToFloat_(sample) {\r\n  f64f32_[0] = sample;\r\n  return f64f32_[0];\r\n}\r\n\r\n/**\r\n * Return the function to change the bit depth of a sample.\r\n * @param {string} original The original bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @param {string} target The new bit depth of the data.\r\n *      One of \"8\" ... \"53\", \"32f\", \"64\"\r\n * @return {!Function}\r\n * @private\r\n */\r\nfunction getBitDepthFunction_(original, target) {\r\n  /** @type {!Function} */\r\n  let func = function(x) {return x;};\r\n  if (original != target) {\r\n    if ([\"32f\", \"64\"].includes(original)) {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = floatToFloat_;\r\n      } else {\r\n        func = floatToInt_;\r\n      }\r\n    } else {\r\n      if ([\"32f\", \"64\"].includes(target)) {\r\n        func = intToFloat_;\r\n      } else {\r\n        func = intToInt_;\r\n      }\r\n    }\r\n  }\r\n  return func;\r\n}\r\n\r\n/**\r\n * Validate the bit depth.\r\n * @param {string} bitDepth The original bit depth.\r\n *     Should be one of \"8\" ... \"53\", \"32f\" or \"64\".\r\n * @throws {Error} If any argument does not meet the criteria.\r\n * @private\r\n */\r\nfunction validateBitDepth_(bitDepth) {\r\n  if ((bitDepth != \"32f\" && bitDepth != \"64\") &&\r\n      (parseInt(bitDepth, 10) < \"8\" || parseInt(bitDepth, 10) > \"53\")) {\r\n    throw new Error(\"Invalid bit depth.\");\r\n  }\r\n}\r\n","/*\r\n * endianness: Swap endianness in byte arrays.\r\n * https://github.com/rochars/endianness\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A function to swap endianness in byte buffers.\r\n */\r\n\r\n/**\r\n * @module endianness\r\n */\r\n\r\n/**\r\n * Swap the byte ordering in a buffer. The buffer is modified in place.\r\n * @param {!Array<number|string>|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number=} start The start index. Assumes 0.\r\n * @param {?number=} end The end index. Assumes the buffer length.\r\n * @throws {Error} If the buffer length is not valid.\r\n */\r\nexport default function endianness(bytes, offset, start=0, end=null) {\r\n    let len = end || bytes.length;\r\n    let limit = parseInt(offset / 2, 10);\r\n    if (len % offset) {\r\n        throw new Error(\"Bad buffer length.\");\r\n    }\r\n    let i = start;\r\n    while (i < len) {\r\n        swap(bytes, offset, i, limit);\r\n        i += offset;\r\n    }\r\n}\r\n\r\n/**\r\n * Swap the byte order of a value in a buffer. The buffer is modified in place.\r\n * @param {!Array<number|string>|!Uint8Array} bytes The bytes.\r\n * @param {number} offset The byte offset.\r\n * @param {number} index The start index.\r\n * @private\r\n */\r\nfunction swap(bytes, offset, index, limit) {\r\n    let x = 0;\r\n    let y = offset - 1;\r\n    while(x < limit) {\r\n        let theByte = bytes[index + x];\r\n        bytes[index + x] = bytes[index + y];\r\n        bytes[index + y] = theByte;\r\n        x++;\r\n        y--;\r\n    }\r\n}\r\n","/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The byte-data API.\r\n */\r\n\r\n/** @module byteData */\r\n\r\nimport Integer from './lib/integer.js';\r\n\r\nimport endianness from 'endianness';\r\n\r\nexport {default as types} from './lib/types.js';\r\n\r\n/**\r\n * Pack a number or a string as a byte buffer.\r\n * @param {number|string} value The value.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nexport function pack(value, theType) {\r\n  setUp_(theType);\r\n  return toBytes_([value], theType);\r\n}\r\n\r\n/**\r\n * Pack an array of numbers or strings to a byte buffer.\r\n * @param {!Array<number|string>|string} values The values.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If any of the values are not valid.\r\n */\r\nexport function packArray(values, theType) {\r\n  setUp_(theType);\r\n  return toBytes_(values, theType);\r\n}\r\n\r\n/**\r\n * Pack a number or a string to a existing byte buffer.\r\n * @param {number|string} value The value.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The output buffer.\r\n * @param {number} index The buffer index to write.\r\n * @return {number} The next index to start writing.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nexport function packTo(value, theType, buffer, index) {\r\n  setUp_(theType);\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  return writeBytes_(value,\r\n    theType,\r\n    buffer,\r\n    index,\r\n    index + theType['offset'],\r\n    validate,\r\n    theType['be']);\r\n}\r\n\r\n/**\r\n * Pack a array of numbers or strings to a existing byte buffer.\r\n * @param {!Array<number|string>} values The value.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The output buffer.\r\n * @param {number} index The buffer index to write.\r\n * @return {number} The next index to start writing.\r\n * @throws {Error} If the type definition is not valid.\r\n * @throws {Error} If the value is not valid.\r\n */\r\nexport function packArrayTo(values, theType, buffer, index) {\r\n  setUp_(theType);\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  let be = theType['be'];\r\n  let offset = theType['offset'];\r\n  for (let i=0; i<values.length; i++) {\r\n    index = writeBytes_(\r\n      values[i],\r\n      theType,\r\n      buffer,\r\n      index,\r\n      index + offset,\r\n      validate, be);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a number or a string from a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @return {number|string}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nexport function unpack(buffer, theType) {\r\n  setUp_(theType);\r\n  let values = fromBytes_(\r\n    buffer.slice(0, theType['offset']), theType);\r\n  return values[0];\r\n}\r\n\r\n/**\r\n * Unpack an array of numbers or strings from a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number|string>}\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpackArray(buffer, theType) {\r\n  setUp_(theType);\r\n  return fromBytes_(buffer, theType);\r\n}\r\n\r\n/**\r\n * Unpack a number or a string from a byte buffer index.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @param {number=} index The buffer index to read.\r\n * @return {number|string}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nexport function unpackFrom(buffer, theType, index=0) {\r\n  setUp_(theType);\r\n  return readBytes_(buffer, theType, index);\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers strings from a byte buffer index.\r\n * @param {!Array<number>|!Uint8Array} buffer The byte buffer.\r\n * @param {!Object} theType The type definition.\r\n * @param {number=} start The start index. Assumes 0.\r\n * @param {?number=} end The end index. Assumes the array length.\r\n * @return {!Array<number>}\r\n * @throws {Error} If the type definition is not valid\r\n */\r\nexport function unpackArrayFrom(buffer, theType, start=0, end=null) {\r\n  setUp_(theType);\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  let len = end || buffer.length;\r\n  let values = [];\r\n  for (let i=start; i<len; i+=theType['offset']) {\r\n    values.push(reader_(buffer, i));\r\n  }\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  return values;\r\n}\r\n\r\n/**\r\n * @type {!Int8Array}\r\n * @private\r\n */\r\nconst int8_ = new Int8Array(8);\r\n/**\r\n * @type {!Uint32Array}\r\n * @private\r\n */\r\nconst ui32_ = new Uint32Array(int8_.buffer);\r\n/**\r\n * @type {!Float32Array}\r\n * @private\r\n */\r\nconst f32_ = new Float32Array(int8_.buffer);\r\n/**\r\n * @type {!Float64Array}\r\n * @private\r\n */\r\nconst f64_ = new Float64Array(int8_.buffer);\r\n/**\r\n * @type {Function}\r\n * @private\r\n */\r\nlet reader_;\r\n/**\r\n * @type {Function}\r\n * @private\r\n */\r\nlet writer_;\r\n/**\r\n * @type {Object}\r\n * @private\r\n */\r\nlet gInt_ = {};\r\n\r\n/**\r\n * Turn a byte buffer into what the bytes represent.\r\n * @param {!Array<number|string>|!Uint8Array} buffer An array of bytes.\r\n * @param {!Object} theType The type definition.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction readBytes_(buffer, theType, start) {\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset'], start, start + theType['offset']);\r\n  }\r\n  let value = reader_(buffer, start);\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset'], start, start + theType['offset']);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Turn a byte buffer into what the bytes represent.\r\n * @param {!Array<number|string>|!Uint8Array} buffer An array of bytes.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction fromBytes_(buffer, theType) {\r\n  if (theType['be']) {\r\n    endianness(buffer, theType['offset']);\r\n  }\r\n  let len = buffer.length;\r\n  let values = [];\r\n  len = len - (theType['offset'] - 1);\r\n  for (let i=0; i<len; i+=theType['offset']) {\r\n    values.push(reader_(buffer, i));\r\n  }\r\n  return values;\r\n}\r\n\r\n/**\r\n * Turn numbers and strings to bytes.\r\n * @param {!Array<number|string>|string} values The data.\r\n * @param {!Object} theType The type definition.\r\n * @return {!Array<number|string>} the data as a byte buffer.\r\n * @private\r\n */\r\nfunction toBytes_(values, theType) {\r\n  let j = 0;\r\n  let bytes = [];\r\n  let len = values.length;\r\n  let validate = validateNotNull_;\r\n  if (theType['char']) {\r\n    validate = validateString_;\r\n  }\r\n  for(let i=0; i < len; i++) {\r\n    validate(values[i], theType);\r\n    j = writer_(bytes, values[i], j);\r\n  }\r\n  if (theType['be']) {\r\n    endianness(bytes, theType['offset']);\r\n  }\r\n  return bytes;\r\n}\r\n\r\n/**\r\n * Turn numbers and strings to bytes.\r\n * @param {number|string} value The value to be packed.\r\n * @param {!Object} theType The type definition.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to write the bytes to.\r\n * @param {number} index The index to start writing.\r\n * @param {number} len The end index.\r\n * @param {!Function} validate The function used to validate input.\r\n * @param {boolean} be True if big-endian.\r\n * @return {number} the new index to be written.\r\n * @private\r\n */\r\nfunction writeBytes_(value, theType, buffer, index, len, validate, be) {\r\n  while (index < len) {\r\n    validate(value, theType);\r\n    index = writer_(buffer, value, index);\r\n  }\r\n  if (be) {\r\n    endianness(\r\n      buffer, theType['offset'], index - theType['offset'], index);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Read int values from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction readInt_(bytes, i) {\r\n  return gInt_.read(bytes, i);\r\n}\r\n\r\n/**\r\n * Read 1 16-bit float from bytes.\r\n * Thanks https://stackoverflow.com/a/8796597\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read16F_(bytes, i) {\r\n  let int = gInt_.read(bytes, i);\r\n  let exponent = (int & 0x7C00) >> 10;\r\n  let fraction = int & 0x03FF;\r\n  let floatValue;\r\n  if (exponent) {\r\n    floatValue =  Math.pow(2, exponent - 15) * (1 + fraction / 0x400);\r\n  } else {\r\n    floatValue = 6.103515625e-5 * (fraction / 0x400);\r\n  }\r\n  return floatValue * (int >> 15 ? -1 : 1);\r\n}\r\n\r\n/**\r\n * Read 1 32-bit float from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read32F_(bytes, i) {\r\n  ui32_[0] = gInt_.read(bytes, i);\r\n  return f32_[0];\r\n}\r\n\r\n/**\r\n * Read 1 64-bit float from bytes.\r\n * Thanks https://gist.github.com/kg/2192799\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction read64F_(bytes, i) {\r\n  ui32_[0] = gInt_.read(bytes, i);\r\n  ui32_[1] = gInt_.read(bytes, i + 4);\r\n  return f64_[0];\r\n}\r\n\r\n/**\r\n * Read 1 char from bytes.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} i The index to read.\r\n * @return {string}\r\n * @private\r\n */\r\nfunction readChar_(bytes, i) {\r\n  let chrs = '';\r\n  for(let j=0; j < gInt_.offset; j++) {\r\n    chrs += String.fromCharCode(bytes[i+j]);\r\n  }\r\n  return chrs;\r\n}\r\n\r\n/**\r\n * Write a integer value to a byte buffer.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {!number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction writeInt_(bytes, number, j) {\r\n  return gInt_.write(bytes, number, j);\r\n}\r\n\r\n/**\r\n * Write one 16-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write16F_(bytes, number, j) {\r\n  f32_[0] = number;\r\n  let x = ui32_[0];\r\n  let bits = (x >> 16) & 0x8000;\r\n  let m = (x >> 12) & 0x07ff;\r\n  let e = (x >> 23) & 0xff;\r\n  if (e >= 103) {\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n  }\r\n  bytes[j++] = bits & 0xFF;\r\n  bytes[j++] = bits >>> 8 & 0xFF;\r\n  return j;\r\n}\r\n\r\n/**\r\n * Write one 32-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write32F_(bytes, number, j) {\r\n  f32_[0] = number;\r\n  return gInt_.write(bytes, ui32_[0], j);\r\n}\r\n\r\n/**\r\n * Write one 64-bit float as a binary value.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {number} number The number to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction write64F_(bytes, number, j) {\r\n  f64_[0] = number;\r\n  j = gInt_.write(bytes, ui32_[0], j);\r\n  return gInt_.write(bytes, ui32_[1], j);\r\n}\r\n\r\n/**\r\n * Write one char as a byte.\r\n * @param {!Array<number>|!Uint8Array} bytes An array of bytes.\r\n * @param {string} str The string to write as bytes.\r\n * @param {number} j The index being written in the byte buffer.\r\n * @return {number} The next index to write on the byte buffer.\r\n * @private\r\n */\r\nfunction writeChar_(bytes, str, j) {\r\n  for (let i=0; i<str.length; i++) {\r\n    bytes[j++] = str.charCodeAt(i);\r\n  }\r\n  return j;\r\n}\r\n\r\n/**\r\n * Set the function to unpack the data.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction setReader(theType) {\r\n  if (theType['float']) {\r\n    if (theType['bits'] == 16) {\r\n      reader_ = read16F_;\r\n    } else if(theType['bits'] == 32) {\r\n      reader_ = read32F_;\r\n    } else if(theType['bits'] == 64) {\r\n      reader_ = read64F_;\r\n    }\r\n  } else if (theType['char']) {\r\n    reader_ = readChar_;\r\n  } else {\r\n    reader_ = readInt_;\r\n  }\r\n}\r\n\r\n/**\r\n * Set the function to pack the data.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction setWriter(theType) {\r\n  if (theType['float']) {\r\n    if (theType['bits'] == 16) {\r\n      writer_ = write16F_;\r\n    } else if(theType['bits'] == 32) {\r\n      writer_ = write32F_;\r\n    } else if(theType['bits'] == 64) {\r\n      writer_ = write64F_;\r\n    }\r\n  } else if (theType['char']) {\r\n    writer_ = writeChar_;\r\n  } else {\r\n    writer_ = writeInt_;\r\n  }   \r\n}\r\n\r\n/**\r\n * Validate the type and set up the packing/unpacking functions.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction setUp_(theType) {\r\n  validateType_(theType);\r\n  theType['offset'] = theType['bits'] < 8 ? 1 : Math.ceil(theType['bits'] / 8);\r\n  setReader(theType);\r\n  setWriter(theType);\r\n  if (!theType['char']) {\r\n    gInt_ = new Integer(\r\n      theType['bits'] == 64 ? 32 : theType['bits'],\r\n      theType['float'] ? false : theType['signed']);\r\n  } else {\r\n    // Workaround; should not use Integer when type['char']\r\n    gInt_.offset = theType['bits'] < 8 ? 1 : Math.ceil(theType['bits'] / 8);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateType_(theType) {\r\n  if (!theType) {\r\n    throw new Error('Undefined type.');\r\n  }\r\n  if (theType['float']) {\r\n    validateFloatType_(theType);\r\n  } else {\r\n    if (theType['char']) {\r\n      validateCharType_(theType);\r\n    } else {\r\n      validateIntType_(theType);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of floating point numbers.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateFloatType_(theType) {\r\n  if ([16,32,64].indexOf(theType['bits']) == -1) {\r\n    throw new Error('Not a supported float type.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of char and strings.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateCharType_(theType) {\r\n  if (theType['bits'] < 8 || theType['bits'] % 2) {\r\n    throw new Error('Wrong offset for type char.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate the type definition of integers.\r\n * @param {!Object} theType The type definition.\r\n * @throws {Error} If the type definition is not valid.\r\n * @private\r\n */\r\nfunction validateIntType_(theType) {\r\n  if (theType['bits'] < 1 || theType['bits'] > 53) {\r\n    throw new Error('Not a supported type.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate strings with bad length.\r\n * @param {string|number} value The string to validate.\r\n * @param {!Object} theType The type definition.\r\n * @private\r\n */\r\nfunction validateString_(value, theType) {\r\n  validateNotNull_(value);\r\n  if (value.length > theType['offset']) {\r\n    throw new Error('String is bigger than its type definition.');\r\n  } else if (value.length < theType['offset']) {\r\n    throw new Error('String is smaller than its type definition.');\r\n  }\r\n}\r\n\r\n/**\r\n * Validate that the value is not null.\r\n * @param {string|number} value The value.\r\n * @private\r\n */\r\nfunction validateNotNull_(value) {\r\n  if (value === null || value === undefined) {\r\n    throw new Error('Cannot pack null or undefined values.');\r\n  }\r\n}\r\n","/*\r\n * riff-chunks: Read and write the chunks of RIFF and RIFX files.\r\n * https://github.com/rochars/riff-chunks\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The riff-chunks API and private methods.\r\n */\r\n\r\n/** @module riffChunks */\r\n\r\nimport {pack, unpack, unpackFrom} from 'byte-data';\r\n\r\n\r\n/** @private */\r\nconst uInt32_ = {'bits': 32};\r\n/** @private */\r\nconst fourCC_ = {'bits': 32, 'char': true};\r\n/** @type {number} */\r\nlet head_ = 0;\r\n\r\n/**\r\n * Return the indexes of the chunks in a RIFF/RIFX file.\r\n * @param {!Uint8Array|!Array<number>} buffer The file bytes.\r\n * @return {!Object} The RIFF chunks.\r\n */\r\nexport function riffIndex(buffer) {\r\n    head_ = 0;\r\n    let chunkId = getChunkId_(buffer, 0);\r\n    uInt32_['be'] = chunkId == 'RIFX';\r\n    let format = unpackFrom(buffer, fourCC_, 8);\r\n    head_ += 4;\r\n    return {\r\n        'chunkId': chunkId,\r\n        'chunkSize': getChunkSize_(buffer, 0),\r\n        'format': format,\r\n        'subChunks': getSubChunksIndex_(buffer)\r\n    };\r\n}\r\n\r\n/**\r\n * Pack a RIFF/RIFX file.\r\n * @param {!Object} chunks A object like the return of riffChunks.read().\r\n * @param {boolean} list An optional param indicating if the chunk is LIST.\r\n *      'LIST' chunks should not be rendered as Uint8Array.\r\n * @return {!Array<number>|!Uint8Array} The bytes as Uint8Array when chunkId is\r\n *      'RIFF'/'RIFX' or as Array<number> when chunkId is 'LIST'.\r\n */\r\nexport function write(chunks, list=false) {\r\n    uInt32_['be'] = chunks['chunkId'] == 'RIFX';\r\n    let bytes = pack(chunks['chunkId'], fourCC_).concat(\r\n        pack(chunks['chunkSize'], uInt32_),\r\n        pack(chunks['format'], fourCC_),\r\n        writeSubChunks_(chunks['subChunks']));\r\n    if (!list) {\r\n        bytes = new Uint8Array(bytes);\r\n    }\r\n    return bytes;\r\n}\r\n\r\n/**\r\n * Return the chunks of a RIFF/RIFX file.\r\n * @param {!Uint8Array|!Array<number>} buffer The file bytes.\r\n * @return {!Object} The RIFF chunks.\r\n */\r\nexport function read(buffer) {\r\n    buffer = [].slice.call(buffer);\r\n    let chunkId = getChunkId_(buffer, 0);\r\n    uInt32_['be'] = chunkId == 'RIFX';\r\n    let format = unpack(buffer.slice(8, 12), fourCC_);\r\n    let chunkSize = getChunkSize_(buffer, 0);\r\n    let subChunks = getSubChunks_(buffer);\r\n    return {\r\n        'chunkId': chunkId,\r\n        'chunkSize': chunkSize,\r\n        'format': format,\r\n        'subChunks': subChunks\r\n    };\r\n}\r\n\r\n/**\r\n * Return the sub chunks of a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunksIndex_(buffer) {\r\n    let chunks = [];\r\n    let i = head_;\r\n    while(i <= buffer.length - 8) {\r\n        chunks.push(getSubChunkIndex_(buffer, i));\r\n        i += 8 + chunks[chunks.length - 1]['chunkSize'];\r\n        i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n}\r\n\r\n/**\r\n * Return a sub chunk from a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunkIndex_(buffer, index) {\r\n    let chunk = {\r\n        'chunkId': getChunkId_(buffer, index),\r\n        'chunkSize': getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk['chunkId'] == 'LIST') {\r\n        chunk['format'] = unpackFrom(buffer, fourCC_, index + 8);\r\n        head_ += 4;\r\n        chunk['subChunks'] = getSubChunksIndex_(buffer);\r\n    } else {\r\n        let realChunkSize = chunk['chunkSize'] % 2 ?\r\n            chunk['chunkSize'] + 1 : chunk['chunkSize'];\r\n        head_ = index + 8 + realChunkSize;\r\n        chunk['chunkData'] = {\r\n            'start': index + 8,\r\n            'end': head_\r\n        };\r\n    }\r\n    return chunk;\r\n}\r\n\r\n/**\r\n * Pack the sub chunks of a RIFF file.\r\n * @param {!Array<!Object>} chunks The chunks.\r\n * @return {!Array<number>} The chunk bytes.\r\n * @private\r\n */\r\nfunction writeSubChunks_(chunks) {\r\n    let subChunks = [];\r\n    let i = 0;\r\n    while (i < chunks.length) {\r\n        if (chunks[i]['chunkId'] == 'LIST') {\r\n            subChunks = subChunks.concat(write(chunks[i], true));\r\n        } else {\r\n            subChunks = subChunks.concat(\r\n                pack(chunks[i]['chunkId'], fourCC_),\r\n                pack(chunks[i]['chunkSize'], uInt32_),\r\n                chunks[i]['chunkData']);\r\n        }\r\n        i++;\r\n    }\r\n    return subChunks;\r\n}\r\n\r\n/**\r\n * Return the sub chunks of a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunks_(buffer) {\r\n    let chunks = [];\r\n    let i = 12;\r\n    while(i <= buffer.length - 8) {\r\n        chunks.push(getSubChunk_(buffer, i));\r\n        i += 8 + chunks[chunks.length - 1]['chunkSize'];\r\n        i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n}\r\n\r\n/**\r\n * Return a sub chunk from a RIFF file.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n * @private\r\n */\r\nfunction getSubChunk_(buffer, index) {\r\n    let chunk = {\r\n        'chunkId': getChunkId_(buffer, index),\r\n        'chunkSize': getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk['chunkId'] == 'LIST') {\r\n        chunk['format'] = unpack(\r\n            buffer.slice(index + 8, index + 12), fourCC_);\r\n        chunk['subChunks'] = getSubChunks_(buffer.slice(index));\r\n    } else {\r\n        let slc = chunk['chunkSize'] % 2 ? chunk['chunkSize'] + 1 : chunk['chunkSize'];\r\n        chunk['chunkData'] = buffer.slice(\r\n            index + 8, index + 8 + slc);\r\n    }\r\n    return chunk;\r\n}\r\n\r\n/**\r\n * Return the fourCC_ of a chunk.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {string|number} The id of the chunk.\r\n * @private\r\n */\r\nfunction getChunkId_(buffer, index) {\r\n    head_ += 4;\r\n    return unpackFrom(buffer, fourCC_, index);\r\n}\r\n\r\n/**\r\n * Return the size of a chunk.\r\n * @param {!Uint8Array|!Array<number>} buffer the RIFF file bytes.\r\n * @param {number} index The start index of the chunk.\r\n * @return {string|number} The size of the chunk without the id and size fields.\r\n * @private\r\n */\r\nfunction getChunkSize_(buffer, index) {\r\n    head_ += 4;\r\n    return unpackFrom(buffer, uInt32_, index + 4);\r\n}\r\n","/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * https://github.com/rochars/imaadpcm\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview imaadpcm public API and private methods.\r\n */\r\n\r\n/** @module imaadpcm */\r\n\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst INDEX_TABLE = [\r\n    -1, -1, -1, -1, 2, 4, 6, 8,\r\n    -1, -1, -1, -1, 2, 4, 6, 8];\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst STEP_TABLE = [\r\n    7, 8, 9, 10, 11, 12, 13, 14,\r\n    16, 17, 19, 21, 23, 25, 28, 31,\r\n    34, 37, 41, 45, 50, 55, 60, 66,\r\n    73, 80, 88, 97, 107, 118, 130, 143,\r\n    157, 173, 190, 209, 230, 253, 279, 307,\r\n    337, 371, 408, 449, 494, 544, 598, 658,\r\n    724, 796, 876, 963, 1060, 1166, 1282, 1411,\r\n    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\r\n    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,\r\n    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\r\n    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n    32767];\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderPredicted_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderIndex_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet encoderStep_ = 7;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderPredicted_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderIndex_ = 0;\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nlet decoderStep_ = 7;\r\n\r\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Array<number>} samples A array of samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function encode(samples) {\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = [];\r\n    /** @type {Array<number>} */\r\n    let block = [];\r\n    for (let i=0; i<samples.length; i++) {\r\n        block.push(samples[i]);\r\n        if ((i % 505 == 0 && i != 0) || i == samples.length - 1) {\r\n            adpcmSamples = adpcmSamples.concat(encodeBlock(block));\r\n            block = [];\r\n        }\r\n    }\r\n    return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Array<number>}\r\n */\r\nexport function decode(adpcmSamples, blockAlign=256) {\r\n    /** @type {!Array<number>} */\r\n    let samples = [];\r\n    /** @type {!Array<number>} */\r\n    let block = [];\r\n    for (let i=0; i<adpcmSamples.length; i++) {\r\n        if (i % blockAlign == 0 && i != 0) {            \r\n            samples = samples.concat(decodeBlock(block));\r\n            block = [];\r\n        }\r\n        block.push(adpcmSamples[i]);\r\n    }\r\n    return samples;\r\n}\r\n\r\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function encodeBlock(block) {\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = blockHead_(block[0]);\r\n    for (let i=3; i<block.length; i+=2) {\r\n        /** @type {number} */\r\n        let sample2 = encodeSample_(block[i]);\r\n        /** @type {number} */\r\n        let sample = encodeSample_(block[i + 1]);\r\n        adpcmSamples.push((sample << 4) | sample2);\r\n    }\r\n    while (adpcmSamples.length < 256) {\r\n        adpcmSamples.push(0);\r\n    }\r\n    return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @return {!Array<number>}\r\n */\r\nexport function decodeBlock(block) {\r\n    decoderPredicted_ = sign_((block[1] << 8) | block[0]);\r\n    decoderIndex_ = block[2];\r\n    decoderStep_ = STEP_TABLE[decoderIndex_];\r\n    /** @type {!Array<number>} */\r\n    let result = [\r\n            decoderPredicted_,\r\n            sign_((block[3] << 8) | block[2])\r\n        ];\r\n    for (let i=4; i<block.length; i++) {\r\n        /** @type {number} */\r\n        let original_sample = block[i];\r\n        /** @type {number} */\r\n        let second_sample = original_sample >> 4;\r\n        /** @type {number} */\r\n        let first_sample = (second_sample << 4) ^ original_sample;\r\n        result.push(decodeSample_(first_sample));\r\n        result.push(decodeSample_(second_sample));\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sign_(num) {\r\n    return num > 32768 ? num - 65536 : num;\r\n}\r\n\r\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction encodeSample_(sample) {\r\n    /** @type {number} */\r\n    let delta = sample - encoderPredicted_;\r\n    /** @type {number} */\r\n    let value = 0;\r\n    if (delta >= 0) {\r\n        value = 0;\r\n    } else {\r\n        value = 8;\r\n        delta = -delta;\r\n    }\r\n    /** @type {number} */\r\n    let step = STEP_TABLE[encoderIndex_];\r\n    /** @type {number} */\r\n    let diff = step >> 3;\r\n    if (delta > step) {\r\n        value |= 4;\r\n        delta -= step;\r\n        diff += step;\r\n    }\r\n    step >>= 1;\r\n    if (delta > step) {\r\n        value |= 2;\r\n        delta -= step;\r\n        diff += step;\r\n    }\r\n    step >>= 1;\r\n    if (delta > step) {\r\n        value |= 1;\r\n        diff += step;\r\n    }\r\n    updateEncoder_(value, diff);\r\n    return value;\r\n}\r\n\r\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @private\r\n */\r\nfunction updateEncoder_(value, diff) {\r\n    if (value & 8) {\r\n        encoderPredicted_ -= diff;\r\n    } else {\r\n        encoderPredicted_ += diff;\r\n    }\r\n    if (encoderPredicted_ < -0x8000) {\r\n        encoderPredicted_ = -0x8000;\r\n    } else if (encoderPredicted_ > 0x7fff) {\r\n        encoderPredicted_ = 0x7fff;\r\n    }\r\n    encoderIndex_ += INDEX_TABLE[value & 7];\r\n    if (encoderIndex_ < 0) {\r\n        encoderIndex_ = 0;\r\n    } else if (encoderIndex_ > 88) {\r\n        encoderIndex_ = 88;\r\n    }\r\n}\r\n\r\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction decodeSample_(nibble) {\r\n    /** @type {number} */\r\n    let difference = 0;\r\n    if (nibble & 4) {\r\n        difference += decoderStep_;\r\n    }\r\n    if (nibble & 2) {\r\n        difference += decoderStep_ >> 1;\r\n    }\r\n    if (nibble & 1) {\r\n        difference += decoderStep_ >> 2;\r\n    }\r\n    difference += decoderStep_ >> 3;\r\n    if (nibble & 8) {\r\n        difference = -difference;\r\n    }\r\n    decoderPredicted_ += difference;\r\n    if (decoderPredicted_ > 32767) {\r\n        decoderPredicted_ = 32767;\r\n    } else if (decoderPredicted_ < -32767) {\r\n        decoderPredicted_ = -32767;\r\n    }\r\n    updateDecoder_(nibble);\r\n    return decoderPredicted_;\r\n}\r\n\r\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @private\r\n */\r\nfunction updateDecoder_(nibble) {\r\n    decoderIndex_ += INDEX_TABLE[nibble];\r\n    if (decoderIndex_ < 0) {\r\n        decoderIndex_ = 0;\r\n    } else if (decoderIndex_ > 88) {\r\n        decoderIndex_ = 88;\r\n    }\r\n    decoderStep_ = STEP_TABLE[decoderIndex_];\r\n}\r\n\r\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction blockHead_(sample) {\r\n    encodeSample_(sample);\r\n    /** @type {!Array<number>} */\r\n    let adpcmSamples = [];\r\n    adpcmSamples.push(sample & 0xFF);\r\n    adpcmSamples.push((sample >> 8) & 0xFF);\r\n    adpcmSamples.push(encoderIndex_);\r\n    adpcmSamples.push(0);\r\n    return adpcmSamples;\r\n}\r\n","/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview A-Law codec.\r\n * References:\r\n * https://github.com/deftio/companders\r\n * http://dystopiancode.blogspot.com.br/2012/02/pcm-law-and-u-law-companding-algorithms.html\r\n */\r\n\r\n/** @module alawmulaw/alaw */\r\n\r\n/** @type {!Array<number>} */\r\nconst LOG_TABLE = [\r\n  1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5, \r\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, \r\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7 \r\n];\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit A-Law.\r\n * @param {number} sample A 16-bit linear PCM sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(sample) {\r\n  /** @type {number} */\r\n  let compandedValue; \r\n  sample = (sample ==-32768) ? -32767 : sample;\r\n  /** @type {number} */\r\n  let sign = ((~sample) >> 8) & 0x80; \r\n  if (!sign) {\r\n    sample = sample * -1; \r\n  }\r\n  if (sample > 32635) {\r\n    sample = 32635; \r\n  }\r\n  if (sample >= 256)  {\r\n    /** @type {number} */\r\n    let exponent = LOG_TABLE[(sample >> 8) & 0x7F];\r\n    /** @type {number} */\r\n    let mantissa = (sample >> (exponent + 3) ) & 0x0F; \r\n    compandedValue = ((exponent << 4) | mantissa); \r\n  } else {\r\n    compandedValue = sample >> 4; \r\n  } \r\n  return compandedValue ^ (sign ^ 0x55);\r\n}\r\n\r\n/**\r\n * Decode a 8-bit A-Law sample as 16-bit linear PCM.\r\n * @param {number} aLawSample The 8-bit A-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(aLawSample) {\r\n  /** @type {number} */\r\n  let sign = 0;\r\n  aLawSample ^= 0x55;\r\n  if (aLawSample & 0x80) {\r\n    aLawSample &= ~(1 << 7);\r\n    sign = -1;\r\n  }\r\n  /** @type {number} */\r\n  let position = ((aLawSample & 0xF0) >> 4) + 4;\r\n  /** @type {number} */\r\n  let decoded = 0;\r\n  if (position != 4) {\r\n    decoded = ((1 << position) |\r\n      ((aLawSample & 0x0F) << (position - 4)) |\r\n      (1 << (position - 5)));\r\n  } else {\r\n    decoded = (aLawSample << 1)|1;\r\n  }\r\n  decoded = (sign === 0) ? (decoded) : (-decoded);\r\n  return (decoded * 8) * -1;\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit A-Law samples.\r\n * @param {!Array<number>} samples A array of 16-bit PCM samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let aLawSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    aLawSamples.push(encodeSample(samples[i]));\r\n  }\r\n  return aLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit A-Law samples into 16-bit linear PCM samples.\r\n * @param {!Array<number>} samples A array of 8-bit A-Law samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let pcmSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples.push(decodeSample(samples[i]));\r\n  }\r\n  return pcmSamples;\r\n}\r\n","/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview mu-Law codec.\r\n * References:\r\n * https://github.com/torvalds/linux/blob/master/sound/core/oss/mulaw.c\r\n */\r\n\r\n/** @module alawmulaw/mulaw */\r\n\r\n/**\r\n * @type {number}\r\n * @private\r\n */\r\nconst BIAS = 0x84;\r\n\r\n/**\r\n * Encode a 16-bit linear PCM sample as 8-bit mu-Law.\r\n * @param {number} pcmSample A 16-bit sample\r\n * @return {number}\r\n */\r\nexport function encodeSample(pcmSample) {\r\n  /** @type {number} */\r\n  let mask = 0xFF;\r\n  if (pcmSample < 0) {\r\n    pcmSample = BIAS - pcmSample;\r\n    mask = 0x7F;\r\n  } else {\r\n    pcmSample += BIAS;\r\n  }\r\n  if (pcmSample > 0x7FFF) {\r\n    pcmSample = 0x7FFF;\r\n  }\r\n  /** @type {number} */\r\n  let seg = segmentValue_(pcmSample);\r\n  /** @type {number} */\r\n  let uval = (seg << 4) | ((pcmSample >> (seg + 3)) & 0xF);\r\n  return uval ^ mask;\r\n}\r\n\r\n/**\r\n * Decode a 8-bit mu-Law sample as 16-bit linear PCM.\r\n * @param {number} muLawSample The 8-bit mu-Law sample\r\n * @return {number}\r\n */\r\nexport function decodeSample(muLawSample) {\r\n  muLawSample = ~muLawSample;\r\n  /** @type {number} */\r\n  let t = ((muLawSample & 0xf) << 3) + BIAS;\r\n  t <<= (muLawSample & 0x70) >> 4;\r\n  return ((muLawSample & 0x80) ? (BIAS - t) : (t - BIAS));\r\n}\r\n\r\n/**\r\n * Encode 16-bit linear PCM samples into 8-bit mu-Law samples.\r\n * @param {!Array<number>} samples A array of 16-bit linear PCM samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let muLawSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    muLawSamples.push(encodeSample(samples[i]));\r\n  }\r\n  return muLawSamples;\r\n}\r\n\r\n/**\r\n * Decode 8-bit mu-Law samples into 16-bit linear PCM samples.\r\n * @param {!Array<number>} samples A array of 8-bit mu-Law samples.\r\n * @return {!Array<number>}\r\n */\r\nexport function decode(samples) {\r\n  /** @type {!Array<number>} */\r\n  let pcmSamples = [];\r\n  for (let i=0; i<samples.length; i++) {\r\n    pcmSamples.push(decodeSample(samples[i]));\r\n  }\r\n  return pcmSamples;\r\n}\r\n\r\n/**\r\n * Return the segment value of a PCM sample.\r\n * @param {number} sample\r\n * @return {number}\r\n * @private\r\n */\r\nfunction segmentValue_(sample) {\r\n  /** @type {number} */\r\n  let segment = 0;\r\n  sample >>= 7;\r\n  if (sample & 0xf0) {\r\n    sample >>= 4;\r\n    segment += 4;\r\n  }\r\n  if (sample & 0x0c) {\r\n    sample >>= 2;\r\n    segment += 2;\r\n  }\r\n  if (sample & 0x02) {\r\n    segment += 1;\r\n  }\r\n  return segment;\r\n}\r\n","/*\r\n * byte-data: Pack and unpack binary data.\r\n * https://github.com/rochars/byte-data\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Standard type definitions.\r\n */\r\n\r\n/** @module byteData/types */\r\n\r\n/**\r\n * byte-data standard types.\r\n * @type {!Object}\r\n * @const\r\n */\r\nexport default {\r\n  /**\r\n   * A char.\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  chr: {'bits': 8, 'char': true},\r\n  /**\r\n   * A 4-char string\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  fourCC: {'bits': 32, 'char': true},\r\n  /**\r\n   * Booleans\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  bool: {'bits': 1},\r\n  /**\r\n   * Signed 2-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int2: {'bits': 2, 'signed': true},\r\n  /**\r\n   * Unsigned 2-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt2: {'bits': 2},\r\n  /**\r\n   * Signed 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int4: {'bits': 4, 'signed': true},\r\n  /**\r\n   * Unsigned 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt4: {'bits': 4},\r\n  /**\r\n   * Signed 8-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int8: {'bits': 8, 'signed': true},\r\n  /**\r\n   * Unsigned 4-bit integers\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt8: {'bits': 8},\r\n  // LE\r\n  /**\r\n   * Signed 16-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int16 : {'bits': 16, 'signed': true},\r\n  /**\r\n   * Unsigned 16-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt16: {'bits': 16},\r\n  /**\r\n   * Half-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float16: {'bits': 16, 'float': true},\r\n  /**\r\n   * Signed 24-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int24: {'bits': 24, 'signed': true},\r\n  /**\r\n   * Unsigned 24-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt24: {'bits': 24},\r\n  /**\r\n   * Signed 32-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int32: {'bits': 32, 'signed': true},\r\n  /**\r\n   * Unsigned 32-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt32: {'bits': 32},\r\n  /**\r\n   * Single-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float32: {'bits': 32, 'float': true},\r\n  /**\r\n   * Signed 40-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int40: {'bits': 40, 'signed': true},\r\n  /**\r\n   * Unsigned 40-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt40: {'bits': 40},\r\n  /**\r\n   * Signed 48-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int48: {'bits': 48, 'signed': true},\r\n  /**\r\n   * Unsigned 48-bit integers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt48: {'bits': 48},\r\n  /**\r\n   * Double-precision floating-point numbers little-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float64: {'bits': 64, 'float': true},\r\n  // BE\r\n  /**\r\n   * Signed 16-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int16BE : {'bits': 16, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 16-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt16BE: {'bits': 16, 'be': true},\r\n  /**\r\n   * Half-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float16BE: {'bits': 16, 'float': true, 'be': true},\r\n  /**\r\n   * Signed 24-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int24BE: {'bits': 24, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 24-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt24BE: {'bits': 24, 'be': true},\r\n  /**\r\n   * Signed 32-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int32BE: {'bits': 32, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 32-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt32BE: {'bits': 32, 'be': true},\r\n  /**\r\n   * Single-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float32BE: {'bits': 32, 'float': true, 'be': true},\r\n  /**\r\n   * Signed 40-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int40BE: {'bits': 40, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 40-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt40BE: {'bits': 40, 'be': true},\r\n  /**\r\n   * Signed 48-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  int48BE: {'bits': 48, 'signed': true, 'be': true},\r\n  /**\r\n   * Unsigned 48-bit integers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  uInt48BE: {'bits': 48, 'be': true},\r\n  /**\r\n   * Double-precision floating-point numbers big-endian\r\n   * @type {!Object}\r\n   * @export\r\n   */\r\n  float64BE: {'bits': 64, 'float': true, 'be': true},\r\n};\r\n","/*\r\n * alawmulaw: A-Law and mu-Law codecs in JavaScript.\r\n * https://github.com/rochars/alawmulaw\r\n *\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The alawmulaw API.\r\n */\r\n\r\n/**\r\n * @module alawmulaw\r\n */\r\n\r\nimport * as alaw from './lib/alaw';\r\nimport * as mulaw from './lib/mulaw';\r\n\r\nexport default {\r\n\t/**\r\n\t * @type {!Object}\r\n\t * @export\r\n\t */\r\n\t'alaw': alaw,\r\n\t/**\r\n\t * @type {!Object}\r\n\t * @export\r\n\t */\r\n\t'mulaw': mulaw\r\n};\r\n"],"sourceRoot":""}